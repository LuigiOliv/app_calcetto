<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcetto Rating App v3</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>	
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyC_81ukybf3QOFFvJcgDWMgbor4Z7k1bgI",
        authDomain: "calcetto-af1e0.firebaseapp.com",
        projectId: "calcetto-af1e0",
        storageBucket: "calcetto-af1e0.firebasestorage.app",
        messagingSenderId: "1035881443344",
        appId: "1:1035881443344:web:2690813dc00bce70d19a95"
      };
      firebase.initializeApp(firebaseConfig);
      const db = firebase.firestore();
    </script>
</head>
<!-- 
================================================================================
  CALCETTO RATING APP
  ¬© 2025 Luigi Oliviero - Tutti i diritti riservati
  
  Questo software √® protetto da copyright e leggi sulla propriet√† intellettuale.
  
  √à SEVERAMENTE VIETATO:
  - Copiare, riprodurre o distribuire questo codice
  - Creare opere derivate senza autorizzazione scritta
  - Utilizzare per scopi commerciali senza licenza
  - Rimuovere o modificare questo avviso di copyright
  
  Uso non autorizzato sar√† perseguito legalmente secondo le leggi italiane 
  ed europee sulla propriet√† intellettuale.
  
  Per licenze commerciali o autorizzazioni: luigi.oliviero@gmail.com
  
  ---
  
  CALCETTO RATING APP
  ¬© 2025 Luigi Oliviero - All Rights Reserved
  
  This software is protected by copyright and intellectual property laws.
  
  STRICTLY PROHIBITED:
  - Copying, reproducing, or distributing this code
  - Creating derivative works without written authorization
  - Commercial use without license
  - Removing or modifying this copyright notice
  
  Unauthorized use will be prosecuted under Italian and European IP laws.
  
  For commercial licensing or permissions: luigi.oliviero@gmail.com
  
  Version: 1.0 | Date: November 2025
================================================================================ -->
<body>
    <div id="root">
        <div className="login-container">
            <div className="login-card">
                <h2>‚öΩ Caricamento...</h2>
                <p>Se rimani bloccato qui, prova a ricaricare la pagina</p>
            </div>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const ADMIN_EMAIL = 'luigi.oliviero@gmail.com';
        
        // üéØ VALORE INIZIALE VOTAZIONI PARTITE (scala 1-10)
        const DEFAULT_VOTE_VALUE = 6.0;  // ‚Üê Cambia questo valore come preferisci

        const SKILLS = {
            tecniche: ['Tiro', 'Passaggio corto', 'Passaggio lungo', 'Contrasto', 'Controllo'],
            tattiche: ['Visione di gioco', 'Senso della posizione', 'Spirito di sacrificio', 'Letture difensive', 'Costruzione'],
            fisiche: ['Resistenza', 'Scatto', 'Progressione', 'Presenza fisica', 'Cazzimma']
        };

		const shortSKILLS =  {
    	    tecniche: ['TIR', 'PsC', 'PsL', 'CST', 'CTR'],
            tattiche: ['VIS', 'PSZ', 'SAC', 'DIF', 'REG'],
            fisiche: ['RES', 'SCT', 'PRG', 'FIS', 'CZM']
    };
		
		
		const SKILLS_GOALKEEPER = {
    tecniche: ['Parate', 'Uscite', 'Rinvii (piedi)', 'Rilanci (mani)', 'Controllo palla'],
    tattiche: ['Posizionamento', 'Comunicazione', 'Lettura del gioco', 'Gestione area', 'Prima costruzione'],
    fisiche: ['Reattivit√†/Agilit√†', 'Riflessi', 'Elevazione', 'Resistenza', 'Plasticit√† (tuffi)']
};

		const shortSKILLS_GK =  {
    	    tecniche: ['PRT', 'USC', 'RNV', 'RLC', 'CTR'],
            tattiche: ['PSZ', 'CMZ', 'LET', 'GES', 'REG'],
            fisiche: ['AGL', 'RFL', 'ELV', 'RES', 'TUF']
    };

		
const getSkillsForPlayer = (player) => {
    return player.isGoalkeeper ? SKILLS_GOALKEEPER : SKILLS;
};
const getShortSkillsForPlayer = (player) => {
    return player.isGoalkeeper ? shortSKILLS_GK : shortSKILLS;
};

        const ROLES = [
            'Portiere', 'Difensore centrale', 'Difensore laterale sx', 'Difensore laterale dx',
            'Centrocampista difensivo', 'Centrocampista offensivo', 'Mezzala sx', 'Mezzala dx', 'Centravanti'
        ];

        const storage = {
            getUsers: async () => {
                const snapshot = await db.collection('users').get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },
            setUsers: async (users) => {
                const batch = db.batch();
                users.forEach(user => {
                    const ref = db.collection('users').doc(user.id);
                    batch.set(ref, user);
                });
                await batch.commit();
            },
            updateUser: async (user) => {
                await db.collection('users').doc(user.id).set(user);
            },
            getVotes: async () => {
                const snapshot = await db.collection('votes').get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },
            addVote: async (vote) => {
                await db.collection('votes').add(vote);
            },
            setVotes: async (votes) => {
                const batch = db.batch();
                votes.forEach((vote, index) => {
                    const ref = db.collection('votes').doc(`vote_${Date.now()}_${index}`);
                    batch.set(ref, vote);
                });
                await batch.commit();
            },
            getCurrentUser: () => {
                const user = localStorage.getItem('calcetto_current_user');
                return user ? JSON.parse(user) : null;
            },
            setCurrentUser: (user) => {
                if (user) {
                    localStorage.setItem('calcetto_current_user', JSON.stringify(user));
                } else {
                    localStorage.removeItem('calcetto_current_user');
                }
            },
            clearAll: () => {
                localStorage.removeItem('calcetto_current_user');
            },
            getMatches: async () => {
                const snapshot = await db.collection('matches')
                    .orderBy('date', 'desc')
                    .limit(20)
                    .get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },
            getMatch: async (matchId) => {
                const doc = await db.collection('matches').doc(matchId).get();
                return doc.exists ? { id: doc.id, ...doc.data() } : null;
            },
            createMatch: async (matchData) => {
                const ref = await db.collection('matches').add({
                    ...matchData,
                    status: 'OPEN',
                    teams: { gialli: [], verdi: [] },
                    score: null,
                    topScorer: null,
                    topScorerGoals: null,
                    createdAt: Date.now()
                });
                return ref.id;
            },
            // Aggiorna partita (SOLO ADMIN)
            updateMatch: async (matchId, updates) => {
                await db.collection('matches').doc(matchId).update(updates);
            },

// ‚úÖ MODIFICATA: Cancella partita + sotto-collezioni automaticamente
    deleteMatch: async (matchId) => {
        const batch = db.batch();
        
        // Cancella registrations (sotto-collezione)
        const regs = await db.collection('matches')
            .doc(matchId)
            .collection('registrations')
            .get();
        regs.forEach(doc => batch.delete(doc.ref));
        
        // Cancella match_votes (sotto-collezione)
        const votes = await db.collection('matches')
            .doc(matchId)
            .collection('match_votes')
            .get();
        votes.forEach(doc => batch.delete(doc.ref));
        
        // Cancella match
        batch.delete(db.collection('matches').doc(matchId));
        
        await batch.commit();
    },

            // ============================================================================
            // FUNZIONI REGISTRATIONS
            // ============================================================================
            
    // ‚úÖ MODIFICATA: Ottiene tutte le iscrizioni per una partita
    getRegistrations: async (matchId) => {
        const snapshot = await db.collection('matches')
            .doc(matchId)
            .collection('registrations')
            .get();
        const registrations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        // Ordina lato client per evitare indice composito
        return registrations.sort((a, b) => a.registeredAt - b.registeredAt);
    },

    // ‚úÖ MODIFICATA: Iscrive un giocatore
    registerPlayer: async (matchId, player) => {
        await db.collection('matches')
            .doc(matchId)
            .collection('registrations')
            .doc(player.id)  // userId come document ID
            .set({
                playerId: player.id,
                playerName: player.name,
                isGoalkeeper: player.isGoalkeeper || false,
                registeredAt: Date.now(),
                registeredBy: player.id
            });
        // Nota: matchId non serve pi√π nei dati, √® gi√† nel path!
    },

    // ‚úÖ MODIFICATA: Admin iscrive un altro giocatore
    registerPlayerByAdmin: async (matchId, player, adminId) => {
        await db.collection('matches')
            .doc(matchId)
            .collection('registrations')
            .doc(player.id)  // userId come document ID
            .set({
                playerId: player.id,
                playerName: player.name,
                isGoalkeeper: player.isGoalkeeper || false,
                registeredAt: Date.now(),
                registeredBy: adminId
            });
    },

    // ‚úÖ MODIFICATA: Disiscrivi giocatore
    unregisterPlayer: async (matchId, playerId) => {
        await db.collection('matches')
            .doc(matchId)
            .collection('registrations')
            .doc(playerId)
            .delete();
    },

            // ============================================================================
            // FUNZIONI MATCH_VOTES
            // ============================================================================

    // ‚úÖ MODIFICATA: Ottiene tutti i voti per una partita
    getMatchVotes: async (matchId) => {
        const snapshot = await db.collection('matches')
            .doc(matchId)
            .collection('match_votes')
            .get();
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    },

    // ‚úÖ MODIFICATA: Ottiene il voto di un giocatore specifico
    getMyMatchVote: async (matchId, voterId) => {
        const doc = await db.collection('matches')
            .doc(matchId)
            .collection('match_votes')
            .doc(voterId)  // voterId come document ID
            .get();
        return doc.exists ? { id: doc.id, ...doc.data() } : null;
    },

    // ‚úÖ MODIFICATA: Salva nuovo voto
    saveMatchVote: async (matchId, voterId, voterTeam, votes) => {
        await db.collection('matches')
            .doc(matchId)
            .collection('match_votes')
            .doc(voterId)  // voterId come document ID
            .set({
                voterId,
                voterTeam,
                votes,
                submittedAt: Date.now(),
                lastModifiedAt: Date.now()
            });
        // Nota: matchId non serve pi√π nei dati!
    },

    // ‚úÖ MODIFICATA: Modifica voto esistente
    updateMatchVote: async (matchId, voterId, votes) => {
        await db.collection('matches')
            .doc(matchId)
            .collection('match_votes')
            .doc(voterId)
            .update({
                votes,
                lastModifiedAt: Date.now()
            });
    },

            // Controlla e aggiorna automaticamente lo status della partita
            checkAndUpdateMatchStatus: async (match) => {
                if (!match) return match;
                // üëá AGGIUNTO: Rispetta override manuale admin
    if (match.manualOverride && match.manualOverrideUntil) {
        if (Date.now() < match.manualOverrideUntil) {
            console.log(`üõ°Ô∏è Manual override attivo fino a ${new Date(match.manualOverrideUntil).toLocaleString()}`);
            console.log(`üõ°Ô∏è Salto auto-update per match ${match.id}`);
            return match;
        } else {
            console.log(`‚è∞ Manual override scaduto, rimuovo flag`);
            await db.collection('matches').doc(match.id).update({ 
                manualOverride: false,
                manualOverrideUntil: null
            });
        }
    }
    // üëÜ FINE AGGIUNTA
                const now = new Date();
                const matchDate = new Date(match.date);
                const votingDeadline = new Date(match.votingDeadline);
                
                let newStatus = match.status;
                let needsUpdate = false;
                
                // OPEN ‚Üí CLOSED: 50 minuti prima della partita
                if (match.status === 'OPEN') {
                    const closingTime = new Date(matchDate.getTime() - 50 * 60 * 1000); // 30 min prima
                    if (now >= closingTime) {
                        newStatus = 'CLOSED';
                        needsUpdate = true;
                    }
                }
                
                // CLOSED ‚Üí VOTING: 2 ore dopo la partita (solo se ci sono squadre E risultato)
                if (match.status === 'CLOSED') {
                    const votingOpenTime = new Date(matchDate.getTime() + 2 * 60 * 60 * 1000); // 2 ore dopo
                    const hasTeams = match.teams && 
                                    match.teams.gialli && 
                                    match.teams.gialli.length > 0 && 
                                    match.teams.verdi && 
                                    match.teams.verdi.length > 0;
                    const hasScore = match.score && 
                                    match.score.gialli !== null && 
                                    match.score.verdi !== null;
                    
                    if (now >= votingOpenTime && hasTeams && hasScore) {
                        newStatus = 'VOTING';
                        needsUpdate = true;
                    }
                }
                
                // VOTING ‚Üí COMPLETED: quando passa la deadline (6 giorni dopo partita)
                if (match.status === 'VOTING') {
                    if (now >= votingDeadline) {
                        newStatus = 'COMPLETED';
                        needsUpdate = true;
                    }
                }
                
                // Aggiorna se necessario
                if (needsUpdate) {
                    await db.collection('matches').doc(match.id).update({ status: newStatus });
                    return { ...match, status: newStatus };
                }
                
                return match;
            }
        };  // üëà Chiude oggetto storage


        
        const utils = {
            calculateAverages: (playerId, votes, player) => {
                const playerVotes = votes.filter(v => v.playerId === playerId);
                if (playerVotes.length === 0) return null;
                const averages = {};
                const skills = player ? getSkillsForPlayer(player) : SKILLS;
                const allSkills = [...skills.tecniche, ...skills.tattiche, ...skills.fisiche];
                allSkills.forEach(skill => {
                    const values = playerVotes.map(v => v.ratings[skill]).filter(v => v !== undefined);
                    if (values.length > 0) {
                        averages[skill] = values.reduce((a, b) => a + b, 0) / values.length;
                    }
                });
                return averages;
            },
            calculateOverall: (averages) => {
                if (!averages) return null;
                const values = Object.values(averages);
                if (values.length === 0) return null;
                return values.reduce((a, b) => a + b, 0) / values.length;
            },


            calculateCategoryOverall: (averages, category, player) => {
                if (!averages) return null;
                const skills = player ? getSkillsForPlayer(player) : SKILLS;
                const categorySkills = skills[category];
                const values = categorySkills.map(s => averages[s]).filter(v => v !== undefined);
                if (values.length === 0) return null;
                return values.reduce((a, b) => a + b, 0) / values.length;
            },
            countVotes: (playerId, votes) => {
                return votes.filter(v => v.playerId === playerId).length;
            },
            toBase10: (value) => {
                return (value / 4) * 10;
            },
            getInitials: (name) => {
                return name.substring(0, 2).toUpperCase();
            },

            // ============================================================================
            // HELPER FUNCTIONS PER PARTITE - Aggiungi dentro l'oggetto utils
            // ============================================================================

            // Formatta data partita (es: "Gioved√¨ 29 Novembre")
            formatMatchDate: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['Domenica', 'Luned√¨', 'Marted√¨', 'Mercoled√¨', 'Gioved√¨', 'Venerd√¨', 'Sabato'];
                const mesi = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 
                              'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'];
                return `${giorni[date.getDay()]} ${date.getDate()} ${mesi[date.getMonth()]}`;
            },

            // Formatta data completa (es: "Gioved√¨ 29 Novembre 2024")
            formatMatchDateFull: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['Domenica', 'Luned√¨', 'Marted√¨', 'Mercoled√¨', 'Gioved√¨', 'Venerd√¨', 'Sabato'];
                const mesi = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 
                              'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'];
                return `${giorni[date.getDay()]} ${date.getDate()} ${mesi[date.getMonth()]} ${date.getFullYear()}`;
            },

            // Formatta ora (es: "21:20")
            formatTime: (dateString) => {
                const date = new Date(dateString);
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${hours}:${minutes}`;
            },

            // Formatta deadline display (es: "luned√¨ 24 novembre")
            formatDeadlineDisplay: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['domenica', 'luned√¨', 'marted√¨', 'mercoled√¨', 'gioved√¨', 'venerd√¨', 'sabato'];
                const mesi = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 
                              'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
                return `${giorni[date.getDay()]} ${date.getDate()} ${mesi[date.getMonth()]}`;
            },

            // Formatta deadline breve (es: "Lun 24, 20:00")
            formatDeadline: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
                const day = date.getDate();
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${giorni[date.getDay()]} ${day}, ${hours}:${minutes}`;
            },

            // Renderizza icone guanti portieri (0, 1 o 2)
            renderGoalkeeperIcons: (count) => {
                if (count === 0) return '';
                if (count === 1) return 'üß§';
                return 'üß§üß§';
            },

            // Trova il nome di un giocatore dal suo ID
            getPlayerNameById: (playerId, users) => {
                // Prova prima con users se disponibile
                if (users && users.length > 0) {
                    const player = users.find(u => u.id === playerId);
                    if (player) return player.name;
                }
                // Fallback: mostra solo ID
                return playerId;
            }
        };

        function LoginPage({ onLogin }) {
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            const handleGoogleLogin = () => {
                setLoading(true);
                setError('');
                const provider = new firebase.auth.GoogleAuthProvider();
                firebase.auth().signInWithPopup(provider)
                    .then((result) => { onLogin(result.user.email); })
                    .catch((err) => {
                        console.error(err);
                        setError('Errore: ' + err.message);
                        setLoading(false);
                    });
            };

            return (
                <div className="login-container">
                    <div className="login-card">
                        <h1>‚öΩ Calcetto Rating</h1>
                        <p>Valuta i tuoi compagni di squadra</p>
                        {error && <p className="error-message">{error}</p>}
                        <button className="google-btn" onClick={handleGoogleLogin} disabled={loading}>
                            <span>üîê</span>
                            {loading ? 'Accesso in corso...' : 'Accedi con Google'}
                        </button>
                        <p className="login-hint">Al primo accesso potrai associare il tuo profilo</p>
                    </div>
                </div>
            );
        }

        function ClaimProfileModal({ users, onClaim, onNewPlayer }) {
            const [selectedPlayer, setSelectedPlayer] = useState('');
            const [newPlayerName, setNewPlayerName] = useState('');
            const availablePlayers = users.filter(u => !u.claimed && !u.id.startsWith('seed'));

            return (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>üëã Benvenuto!</h2>
                        <p>Chi sei tra questi giocatori?</p>
                        <div className="form-group">
                            <label>Seleziona il tuo nome:</label>
                            <select value={selectedPlayer} onChange={(e) => setSelectedPlayer(e.target.value)}>
                                <option value="">-- Seleziona il tuo profilo --</option>
                                {availablePlayers.map(player => (
                                    <option key={player.id} value={player.id}>{player.name}</option>
                                ))}
                            </select>
                        </div>
                        <button className="btn btn-primary full-width" onClick={() => selectedPlayer && onClaim(selectedPlayer)} disabled={!selectedPlayer}>
                            ‚úì Sono io!
                        </button>
                        <div className="modal-divider">
                            <p className="modal-hint">Non trovi il tuo nome?</p>
                            <input type="text" placeholder="Scrivi il tuo nome e cognome" value={newPlayerName} onChange={(e) => setNewPlayerName(e.target.value)} />
                            <button className="btn btn-secondary full-width" onClick={() => onNewPlayer(newPlayerName)} disabled={!newPlayerName.trim()}>
                                + Sono un nuovo giocatore
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        function RoleSelectionModal({ onSave }) {
            const [preferredRole, setPreferredRole] = useState('');
            const [otherRoles, setOtherRoles] = useState([]);

            const handleOtherRoleToggle = (role) => {
                if (otherRoles.includes(role)) {
                    setOtherRoles(otherRoles.filter(r => r !== role));
                } else {
                    setOtherRoles([...otherRoles, role]);
                }
            };

const handleSubmit = () => {
    if (!preferredRole) { alert('Seleziona il tuo ruolo preferito'); return; }
    // I portieri non devono obbligatoriamente scegliere altri ruoli
    const isGoalkeeper = preferredRole === 'Portiere';
    if (!isGoalkeeper && otherRoles.length < 2) { 
        alert('Seleziona almeno 2 altri ruoli'); 
        return; 
    }
    onSave(preferredRole, otherRoles);
};

            const availableOtherRoles = ROLES.filter(r => r !== preferredRole);

            return (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>‚öΩ Benvenuto!</h2>
                        <p>Prima di iniziare, raccontaci qualcosa di te</p>
                        <div className="form-group">
                            <label>Qual √® il tuo ruolo preferito? *</label>
                            <select value={preferredRole} onChange={(e) => setPreferredRole(e.target.value)}>
                                <option value="">-- Seleziona --</option>
                                {ROLES.map(role => (<option key={role} value={role}>{role}</option>))}
                            </select>
                        </div>
                        <div className="form-group">
<label>In quali altri ruoli ti adatti? {preferredRole === 'Portiere' ? '(opzionale)' : '(min. 2) *'}</label>
                            <div className="checkbox-group">
                                {availableOtherRoles.map(role => (
                                    <div key={role} className="checkbox-item">
                                        <input type="checkbox" id={`role-${role}`} checked={otherRoles.includes(role)} onChange={() => handleOtherRoleToggle(role)} />
                                        <label htmlFor={`role-${role}`}>{role}</label>
                                    </div>
                                ))}
                            </div>
                        </div>
						<button className={`btn btn-primary full-width ${(!preferredRole || (preferredRole !== 'Portiere' && otherRoles.length < 2)) ? 'btn-disabled' : ''}`} onClick={handleSubmit} disabled={!preferredRole || (preferredRole !== 'Portiere' && otherRoles.length < 2)}>
    Conferma {preferredRole !== 'Portiere' && otherRoles.length < 2 && preferredRole ? `(${otherRoles.length}/2 ruoli)` : ''}
						</button>
                    </div>
                </div>
            );
        }
function RoleEditModal({ user, onClose, onSuccess }) {
    const [preferredRole, setPreferredRole] = useState(user.preferredRole || '');
    const [otherRoles, setOtherRoles] = useState(user.otherRoles || []);

    const handleOtherRoleToggle = (role) => {
        if (otherRoles.includes(role)) {
            setOtherRoles(otherRoles.filter(r => r !== role));
        } else {
            setOtherRoles([...otherRoles, role]);
        }
    };

    const handleSubmit = async () => {
        if (!preferredRole) { 
            alert('Seleziona il tuo ruolo preferito'); 
            return; 
        }
        if (otherRoles.length < 2) { 
            alert('Seleziona almeno 2 altri ruoli'); 
            return; 
        }
        
        const updatedUser = { 
            ...user, 
            preferredRole, 
            otherRoles 
        };
        
        await storage.updateUser(updatedUser);
        storage.setCurrentUser(updatedUser);
        onSuccess();
    };

    const availableOtherRoles = ROLES.filter(r => r !== preferredRole);

    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <h2>‚úèÔ∏è Modifica Ruoli</h2>
                <p>Aggiorna le tue preferenze di ruolo</p>
                
                <div className="form-group">
                    <label>Qual √® il tuo ruolo preferito? *</label>
                    <select value={preferredRole} onChange={(e) => setPreferredRole(e.target.value)}>
                        <option value="">-- Seleziona --</option>
                        {ROLES.map(role => (
                            <option key={role} value={role}>{role}</option>
                        ))}
                    </select>
                </div>
                
                <div className="form-group">
                    <label>In quali altri ruoli ti adatti? (min. 2) *</label>
                    <div className="checkbox-group">
                        {availableOtherRoles.map(role => (
                            <div key={role} className="checkbox-item">
                                <input 
                                    type="checkbox" 
                                    id={`edit-role-${role}`} 
                                    checked={otherRoles.includes(role)} 
                                    onChange={() => handleOtherRoleToggle(role)} 
                                />
                                <label htmlFor={`edit-role-${role}`}>{role}</label>
                            </div>
                        ))}
                    </div>
                </div>
                
                <div className="modal-actions">
                    <button className="btn btn-secondary" onClick={onClose}>
                        Annulla
                    </button>
                    <button 
                        className={`btn btn-primary ${(!preferredRole || otherRoles.length < 2) ? 'btn-disabled' : ''}`} 
                        onClick={handleSubmit} 
                        disabled={!preferredRole || otherRoles.length < 2}
                    >
                        Salva Modifiche {otherRoles.length < 2 && preferredRole ? `(${otherRoles.length}/2 ruoli)` : ''}
                    </button>
                </div>
            </div>
        </div>
    );
}

		function ProfileSelectorModal({ profiles, onSelect }) {
    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <h2>üëã Ciao Antonio!</h2>
                <p>Con quale profilo vuoi entrare?</p>
                <div style={{display: 'flex', flexDirection: 'column', gap: '15px', marginTop: '25px'}}>
                    {profiles.map(profile => (
                        <button 
                            key={profile.id}
                            className="btn btn-primary full-width" 
                            onClick={() => onSelect(profile)}
                            style={{fontSize: '1.1rem', padding: '18px'}}
                        >
                            {profile.isGoalkeeper ? 'üß§' : 'üë§'} {profile.name}
                        </button>
                    ))}
                </div>
            </div>
        </div>
    );
}
		
function Header({ user, onLogout, onOpenSettings }) {
    const [showMenu, setShowMenu] = React.useState(false);
    
    return (
        <div className="header">
                    <div className="header-left">
                        <h1>‚öΩ Calcetto del <span style={{color: 'var(--volt)'}}>gioved√¨</span></h1>
                        <p>Dedicata a quelli che il week-end inizia con la partitella</p>
                    </div>
                    <div className="user-info" style={{position: 'relative'}}>
    <div 
        className="avatar" 
        style={{cursor: 'pointer'}}
        onClick={() => setShowMenu(!showMenu)}
    >
        {user.avatar ? <img src={user.avatar} alt={user.name} /> : utils.getInitials(user.name)}
    </div>
    <div onClick={() => setShowMenu(!showMenu)} style={{cursor: 'pointer'}}>
        <div className="user-name">{user.name}</div>
        <div className="user-email">{user.email}</div>
    </div>
    <button 
        className="user-menu-btn" 
        onClick={() => setShowMenu(!showMenu)}
    >
        {showMenu ? '‚úï' : '‚ò∞'}
    </button>
    
    {showMenu && (
        <div className="user-dropdown-menu">
            <button className="dropdown-item" onClick={() => { onOpenSettings(); setShowMenu(false); }}>
                ‚öôÔ∏è Impostazioni
            </button>
            <button className="dropdown-item logout" onClick={() => { onLogout(); setShowMenu(false); }}>
                üö™ Esci
            </button>
        </div>
    )}
</div>
                </div>
            );
        }


// ============================================================================
// COMPONENTI PARTITE
// ============================================================================

function MatchCard({ match, currentUser, users, onClick }) {
    const [registrations, setRegistrations] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        loadRegistrations();
    }, [match.id]);

    const loadRegistrations = async () => {
        try {
            const regs = await storage.getRegistrations(match.id);
            setRegistrations(regs);
        } catch (error) {
            console.error('Errore caricamento iscrizioni:', error);
        }
        setLoading(false);
    };

    const getStatusBadge = () => {
        if (match.status === 'OPEN' || match.status === 'CLOSED') {
            return { text: 'üìù APERTA', class: 'open' };
        }
        if (match.status === 'VOTING') {
            return { text: '‚≠ê DA VOTARE', class: 'voting' };
        }
        return { text: '‚úÖ FINITA', class: 'completed' };
    };

    const countGoalkeepers = () => {
        return registrations.filter(r => r.isGoalkeeper).length;
    };

    const status = getStatusBadge();
    const gkCount = countGoalkeepers();

    if (loading) {
        return (
            <div className="match-card">
                <div className="match-card-center">
                    <h3>Caricamento...</h3>
                </div>
            </div>
        );
    }

    return (
        <div className={`match-card ${status.class}`} onClick={onClick}>
            <div className="match-card-left">
                <span className={`match-status ${status.class}`}>{status.text}</span>
            </div>
            <div className="match-card-center">
                <h3>{utils.formatMatchDate(match.date)}</h3>
            </div>
            <div className="match-card-right">
                {(match.status === 'OPEN' || match.status === 'CLOSED') && (
                    <>
                        <div className="match-info">
                            üë• {registrations.length}/{match.maxPlayers} {utils.renderGoalkeeperIcons(gkCount)}
                        </div>
                        <div className="match-info" style={{fontSize: '0.75rem'}}>
                            Chiude: {utils.formatDeadline(match.registrationDeadlineForced)}
                        </div>
                    </>
                )}
                {match.status === 'VOTING' && match.score && (
                    <>
                        <div className="match-info">
                            Gialli {match.score.gialli}-{match.score.verdi} Verdi
                        </div>
                        <div className="match-info" style={{fontSize: '0.75rem'}}>
                            üó≥Ô∏è Vota entro domenica
                        </div>
                    </>
                )}
                {match.status === 'COMPLETED' && match.score && (
                    <>
                        <div className="match-info">
                            Gialli {match.score.gialli}-{match.score.verdi} Verdi
                        </div>
                        <div className="match-info" style={{fontSize: '0.75rem'}}>
                            üèÜ {utils.getPlayerNameById(match.topScorer, users)}
                        </div>
                    </>
                )}
            </div>
        </div>
    );
}

function MatchesPage({ currentUser, users, onSelectMatch }) {
    const [matches, setMatches] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        loadMatches();
    }, []);

const loadMatches = async () => {
    setLoading(true);
    try {
        const data = await storage.getMatches();
        
        // Controlla e aggiorna status automaticamente
        const updatedMatches = await Promise.all(
            data.map(match => storage.checkAndUpdateMatchStatus(match))
        );
        
        setMatches(updatedMatches);
    } catch (error) {
        console.error('Errore caricamento partite:', error);
    }
    setLoading(false);
};

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üèÜ Le Tue Partite</h2>
            </div>

            {loading ? (
                <div className="no-votes">
                    <h3>Caricamento partite...</h3>
                </div>
            ) : matches.length === 0 ? (
                <div className="no-votes">
                    <h3>Nessuna partita in programma</h3>
                    <p>L'admin creer√† presto la prossima partita!</p>
                </div>
            ) : (
                <div className="matches-list">
                    {matches.map(match => (
                        <MatchCard
                            key={match.id}
                            match={match}
                            currentUser={currentUser}
                            users={users}
                            onClick={() => onSelectMatch(match.id)}
                        />
                    ))}
                </div>
            )}
        </div>
    );
}


// ============================================================================
// VISTA ISCRIZIONI PARTITA
// ============================================================================

function MatchRegistrationView({ match, currentUser, users, onBack, onUpdate }) {
	const [registrations, setRegistrations] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [actionLoading, setActionLoading] = React.useState(false);
	const [showAddPlayerModal, setShowAddPlayerModal] = React.useState(false);
    const [selectedPlayerId, setSelectedPlayerId] = React.useState('');
    const [isGoalkeeper, setIsGoalkeeper] = React.useState(false);

    React.useEffect(() => {
        loadRegistrations();
    }, [match.id]);

    const loadRegistrations = async () => {
        setLoading(true);
        try {
            const regs = await storage.getRegistrations(match.id);
            setRegistrations(regs);
        } catch (error) {
            console.error('Errore caricamento iscrizioni:', error);
        }
        setLoading(false);
    };

    const isRegistered = registrations.some(r => r.playerId === currentUser.id);
    const isClosed = match.status === 'CLOSED';

    const handleRegister = async () => {
        setActionLoading(true);
        try {
            await storage.registerPlayer(match.id, currentUser);
            await loadRegistrations();
            if (onUpdate) onUpdate();
        } catch (error) {
            console.error('Errore iscrizione:', error);
            alert('Errore durante l\'iscrizione. Riprova.');
        }
        setActionLoading(false);
    };

	
	
    const handleUnregister = async (playerId, playerName) => {
        const isCurrentUser = playerId === currentUser.id;
        const message = isCurrentUser 
            ? 'Vuoi disiscriverti dalla partita?' 
            : `Rimuovere ${playerName} dalla partita?`;
        
        if (!confirm(message)) return;

        setActionLoading(true);
        try {
            await storage.unregisterPlayer(match.id, playerId);
            await loadRegistrations();
            if (onUpdate) onUpdate();
        } catch (error) {
            console.error('Errore disiscrizione:', error);
            alert('Errore durante la disiscrizione. Riprova.');
        }
        setActionLoading(false);
    };

	const handleAddPlayer = async () => {
        if (!selectedPlayerId) {
            alert('Seleziona un giocatore!');
            return;
        }

        setActionLoading(true);
        try {
            const player = users.find(u => u.id === selectedPlayerId);
            const playerToAdd = {
                ...player,
                isGoalkeeper: isGoalkeeper
            };
            
            await storage.registerPlayerByAdmin(match.id, playerToAdd, currentUser.id);
            await loadRegistrations();
            if (onUpdate) onUpdate();
            
            // Reset e chiudi modale
            setSelectedPlayerId('');
            setIsGoalkeeper(false);
            setShowAddPlayerModal(false);
        } catch (error) {
            console.error('Errore aggiunta giocatore:', error);
            alert('Errore durante l\'aggiunta. Riprova.');
        }
        setActionLoading(false);
    };

    const getAvailablePlayers = () => {
        const registeredIds = registrations.map(r => r.playerId);
        return users.filter(u => !registeredIds.includes(u.id));
    };

    const countGoalkeepers = () => {
        return registrations.filter(r => r.isGoalkeeper).length;
    };

    if (loading) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>Caricamento...</h2>
                </div>
            </div>
        );
    }

    return (
        <>
            <div className="section-container">
                <div className="detail-card">
                    <div className="detail-header">
                        <span className={`match-status ${isClosed ? 'completed' : 'open'}`}>
                            {isClosed ? 'üîí ISCRIZIONI CHIUSE' : 'üìù ISCRIZIONI APERTE'}
                        </span>

                        <div className="header-info-grid">
                            <div className="header-main">
                                <div className="detail-date">{utils.formatMatchDateFull(match.date)}</div>
                                <div className="detail-time">‚è∞ Ore {utils.formatTime(match.date)}</div>
                                <div className="detail-location">üìç {match.location}</div>
                            </div>
                            <div className="header-aside">
                                <div className="recap-box">
                                    <div className="recap-row">
                                        {utils.renderGoalkeeperIcons(countGoalkeepers())}
                                        <span><strong>{registrations.length}</strong>/{match.maxPlayers}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="detail-content">
                        {/* üÜï SE CI SONO SQUADRE ASSEGNATE, MOSTRA LE SQUADRE */}
                        {isClosed && match.teams && match.teams.gialli && match.teams.gialli.length > 0 ? (
                            <>
                                <div style={{textAlign: 'center', marginBottom: '30px'}}>
                                    <h3 style={{color: 'var(--volt)', fontSize: '1.8rem', marginBottom: '10px'}}>
                                        ‚öîÔ∏è SQUADRE ASSEGNATE
                                    </h3>
                                    <p style={{color: 'var(--text-muted)', fontSize: '0.9rem'}}>
                                        Le squadre sono pronte per la partita!
                                    </p>
                                </div>

                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
                                    gap: '20px',
                                    marginBottom: '20px'
                                }}>
                                    {/* SQUADRA GIALLI */}
                                    <div style={{
                                        background: 'rgba(255, 215, 0, 0.1)',
                                        border: '2px solid #FFD700',
                                        borderRadius: '8px',
                                        padding: '20px'
                                    }}>
                                        <h4 style={{
                                            color: '#FFD700',
                                            fontSize: '1.5rem',
                                            marginBottom: '15px',
                                            textAlign: 'center',
                                            textTransform: 'uppercase',
                                            letterSpacing: '2px'
                                        }}>
                                            üü° GIALLI ({match.teams.gialli.length})
                                        </h4>
                                        <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
                                            {match.teams.gialli.map((player, index) => (
                                                <div key={player.playerId} style={{
                                                    background: 'rgba(255, 255, 255, 0.05)',
                                                    padding: '12px',
                                                    borderRadius: '4px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '12px'
                                                }}>
                                                    <span style={{
                                                        background: 'rgba(255, 215, 0, 0.3)',
                                                        color: '#FFD700',
                                                        width: '28px',
                                                        height: '28px',
                                                        borderRadius: '50%',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        fontSize: '14px',
                                                        fontWeight: 'bold'
                                                    }}>
                                                        {index + 1}
                                                    </span>
                                                    <span style={{flex: 1, fontSize: '15px'}}>
                                                        {player.playerName}
                                                        {player.playerId === currentUser.id && ' (Tu)'}
                                                    </span>
                                                    {player.isGoalkeeper && (
                                                        <span style={{fontSize: '18px'}}>üß§</span>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* SQUADRA VERDI */}
                                    <div style={{
                                        background: 'rgba(72, 187, 120, 0.1)',
                                        border: '2px solid #48bb78',
                                        borderRadius: '8px',
                                        padding: '20px'
                                    }}>
                                        <h4 style={{
                                            color: '#48bb78',
                                            fontSize: '1.5rem',
                                            marginBottom: '15px',
                                            textAlign: 'center',
                                            textTransform: 'uppercase',
                                            letterSpacing: '2px'
                                        }}>
                                            üü¢ VERDI ({match.teams.verdi.length})
                                        </h4>
                                        <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
                                            {match.teams.verdi.map((player, index) => (
                                                <div key={player.playerId} style={{
                                                    background: 'rgba(255, 255, 255, 0.05)',
                                                    padding: '12px',
                                                    borderRadius: '4px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '12px'
                                                }}>
                                                    <span style={{
                                                        background: 'rgba(72, 187, 120, 0.3)',
                                                        color: '#48bb78',
                                                        width: '28px',
                                                        height: '28px',
                                                        borderRadius: '50%',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        fontSize: '14px',
                                                        fontWeight: 'bold'
                                                    }}>
                                                        {index + 1}
                                                    </span>
                                                    <span style={{flex: 1, fontSize: '15px'}}>
                                                        {player.playerName}
                                                        {player.playerId === currentUser.id && ' (Tu)'}
                                                    </span>
                                                    {player.isGoalkeeper && (
                                                        <span style={{fontSize: '18px'}}>üß§</span>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* üÜï ADMIN: MESSAGGIO CHE PU√í ANNULLARE */}
                                {currentUser.isAdmin && (
                                    <div style={{
                                        background: 'rgba(102, 126, 234, 0.1)',
                                        border: '1px solid rgba(102, 126, 234, 0.3)',
                                        borderRadius: '8px',
                                        padding: '15px',
                                        textAlign: 'center',
                                        marginTop: '20px'
                                    }}>
                                        <p style={{color: '#667eea', fontSize: '14px', marginBottom: '10px'}}>
                                            ‚ÑπÔ∏è Per modificare le squadre, torna alla sezione Admin e clicca "üë• Assegna Squadre"
                                        </p>
                                        <p style={{color: 'var(--text-muted)', fontSize: '13px'}}>
                                            Per annullare tutto: "üîì Riapri Iscrizioni" (canceller√† squadre e risultati)
                                        </p>
                                    </div>
                                )}
                            </>
                        ) : (
                            /* VISUALIZZAZIONE NORMALE QUANDO NON CI SONO SQUADRE */
                            <>
                                <div className="players-list">
                                    <h3>üë• Chi Gioca ({registrations.length})</h3>
                                    {registrations.length === 0 ? (
                                        <div className="no-votes">
                                            <p>Nessun iscritto ancora. Sii il primo!</p>
                                        </div>
                                    ) : (
                                        registrations.map(reg => (
                                            <div key={reg.id} className={`player-item ${reg.isGoalkeeper ? 'gk' : ''}`}>
                                                <div className="avatar">{utils.getInitials(reg.playerName)}</div>
                                                <div className="player-info">
                                                    <div className="player-name">
                                                        {reg.playerName}
                                                        {reg.playerId === currentUser.id && ' (Tu)'}
                                                    </div>
                                                    <div className="player-role">
                                                        {reg.isGoalkeeper ? 'üß§ Portiere' : 'Movimento'}
                                                    </div>
                                                </div>

                                                {/* X ROSSA: mostra solo se sono io O se sono admin */}
                                                {(reg.playerId === currentUser.id || currentUser.isAdmin) && !isClosed && (
                                                    <div 
                                                        className="unsubscribe-btn" 
                                                        onClick={() => handleUnregister(reg.playerId, reg.playerName)}
                                                    >
                                                        ‚úï
                                                    </div>
                                                )}
                                            </div>
                                        ))
                                    )}
                                </div>

                                {/* üÜï ADMIN: AGGIUNGI GIOCATORE */}
                                {currentUser.isAdmin && !isClosed && (
                                    <div className="admin-add-player">
                                        <button 
                                            className="btn-add-player" 
                                            onClick={() => setShowAddPlayerModal(true)}
                                        >
                                            + AGGIUNGI GIOCATORE
                                        </button>
                                    </div>
                                )}
                            </>
                        )}

                        {!isClosed && (
                            <div className="deadline-msg">
                                Iscriviti entro le ore 20 del {utils.formatDeadlineDisplay(match.registrationDeadlineDisplay)}<br/>
                                per avere la possibilit√† di cambiare campo se necessario
                            </div>
                        )}

                        {isClosed && (
                            <div className="deadline-msg closed">
                                Le iscrizioni sono chiuse.<br/>
                                L'admin sta preparando le squadre!
                            </div>
                        )}

                        <div className="btn-group">
                            <button className="btn btn-secondary" onClick={onBack}>
                                ‚Üê INDIETRO
                            </button>
                            {!isClosed && (
                                isRegistered ? (
                                    <button className="btn btn-registered" disabled>
                                        ‚úì SONO GI√Ä ISCRITTO
                                    </button>
                                ) : (
                                    <button 
                                        className="btn btn-primary" 
                                        onClick={handleRegister} 
                                        disabled={actionLoading}
                                    >
                                        {actionLoading ? 'Attendere...' : '‚úì ISCRIVITI'}
                                    </button>
                                )
                            )}
                        </div>
                    </div>
                </div>
            </div>

            {/* üÜï MODALE AGGIUNGI GIOCATORE */}
            {showAddPlayerModal && (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>üë• Aggiungi Giocatore</h2>
                        
                        <div className="form-group">
                            <label>Seleziona Giocatore *</label>
                            <select 
                                value={selectedPlayerId}
                                onChange={(e) => setSelectedPlayerId(e.target.value)}
                            >
                                <option value="">-- Seleziona --</option>
                                {getAvailablePlayers().map(player => (
                                    <option key={player.id} value={player.id}>
                                        {player.name}
                                    </option>
                                ))}
                            </select>
                        </div>

                        <div className="form-group">
                            <div className="checkbox-item">
                                <input 
                                    type="checkbox" 
                                    id="admin-gk"
                                    checked={isGoalkeeper}
                                    onChange={(e) => setIsGoalkeeper(e.target.checked)}
                                />
                                <label htmlFor="admin-gk">üß§ √à un portiere</label>
                            </div>
                        </div>

                        <div className="modal-actions">
                            <button 
                                className="btn btn-secondary" 
                                onClick={() => {
                                    setShowAddPlayerModal(false);
                                    setSelectedPlayerId('');
                                    setIsGoalkeeper(false);
                                }}
                            >
                                Annulla
                            </button>
                            <button 
                                className="btn btn-primary" 
                                onClick={handleAddPlayer}
                                disabled={!selectedPlayerId || actionLoading}
                            >
                                {actionLoading ? 'Attendere...' : '‚úì Aggiungi'}
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </>
    );
}

// ============================================================================
// VISTA VOTAZIONI PARTITA
// ============================================================================

function MatchVotingView({ match, currentUser, users, onBack }) {
    const [votes, setVotes] = React.useState({});
    const [hasVoted, setHasVoted] = React.useState(false);
    const [loading, setLoading] = React.useState(true);
    const [submitting, setSubmitting] = React.useState(false);

    React.useEffect(() => {
        loadVotingData();
    }, [match.id]);

    const loadVotingData = async () => {
        setLoading(true);
        try {
            // Controlla se ho gi√† votato
            const myVote = await storage.getMyMatchVote(match.id, currentUser.id);
            if (myVote) {
                setVotes(myVote.votes);
                setHasVoted(true);
            } else {
                // üÜï Inizializza tutti i voti con il valore default
                const playersToVote = [...match.teams.gialli, ...match.teams.verdi]
                    .filter(p => p.playerId !== currentUser.id);
                
                const initialVotes = {};
                playersToVote.forEach(player => {
                    initialVotes[player.playerId] = DEFAULT_VOTE_VALUE;
                });
                setVotes(initialVotes);
            }
        } catch (error) {
            console.error('Errore caricamento voti:', error);
        }
        setLoading(false);
    };

    // Determina il team dell'utente
    const getUserTeam = () => {
        const gialliIds = match.teams.gialli.map(p => p.playerId);
        const verdiIds = match.teams.verdi.map(p => p.playerId);
        if (gialliIds.includes(currentUser.id)) return 'gialli';
        if (verdiIds.includes(currentUser.id)) return 'verdi';
        return null;
    };

    // Ottieni lista giocatori da votare (tutti tranne me stesso)
    const getPlayersToVote = () => {
        const allPlayers = [...match.teams.gialli, ...match.teams.verdi];
        return allPlayers.filter(p => p.playerId !== currentUser.id);
    };

    // Ottieni team di un giocatore
    const getPlayerTeam = (player) => {
        const gialliIds = match.teams.gialli.map(p => p.playerId);
        if (gialliIds.includes(player.playerId)) return 'gialli';
        return 'verdi';
    };

    const handleVoteChange = (playerId, value) => {
        setVotes(prev => ({
            ...prev,
            [playerId]: parseFloat(value)
        }));
    };

    const isComplete = () => {
        const playersToVote = getPlayersToVote();
        return playersToVote.every(player => votes[player.playerId] !== undefined);
    };

    const handleSubmit = async () => {
        if (!isComplete()) {
            alert('Devi votare tutti i giocatori prima di inviare!');
            return;
        }

        setSubmitting(true);
        try {
            const userTeam = getUserTeam();
            await storage.saveMatchVote(match.id, currentUser.id, userTeam, votes);
            setHasVoted(true);
            alert('‚úÖ Voti inviati con successo!');
        } catch (error) {
            console.error('Errore invio voti:', error);
            alert('Errore durante l\'invio dei voti. Riprova.');
        }
        setSubmitting(false);
    };

    const handleModify = () => {
        setHasVoted(false);
    };

    const isDeadlinePassed = () => {
        return new Date() > new Date(match.votingDeadline);
    };

const canModify = hasVoted && !isDeadlinePassed();
const isLocked = hasVoted && isDeadlinePassed();

// üîí CONTROLLO: Solo chi ha giocato pu√≤ votare
const userTeam = getUserTeam();
const isRegistered = userTeam !== null;

if (!isRegistered) {
    return (
        <div className="section-container">
            <div className="section-header">
                <button className="btn-back" onClick={onBack}>‚Üê Indietro</button>
                <h2>‚≠ê Votazione Partita</h2>
            </div>
            <div className="no-votes">
                <h3>üö´ Accesso Negato</h3>
                <p>Solo i giocatori che hanno partecipato a questa partita possono votare.</p>
                <p style={{marginTop: '20px', opacity: 0.7}}>
                    Non risulti iscritto tra i Gialli o i Verdi di questa partita.
                </p>
            </div>
        </div>
    );
}

if (loading) {
    return (
            <div className="section-container">
                <div className="section-header">
                    <h2>Caricamento...</h2>
                </div>
            </div>
        );
    }

    const playersToVote = getPlayersToVote();
    const gialliToVote = playersToVote.filter(p => getPlayerTeam(p) === 'gialli');
    const verdiToVote = playersToVote.filter(p => getPlayerTeam(p) === 'verdi');

    return (
        <div className="section-container">
            <div className="voting-card">
                <div className="voting-header">
                    <span className="match-status voting">‚≠ê DA VOTARE</span>

                    <div className="voting-score">
                        <span className="team-name gialli">GIALLI</span>
                        <span className="score">{match.score.gialli} - {match.score.verdi}</span>
                        <span className="team-name verdi">VERDI</span>
                    </div>

                    <div className="voting-info">
                        <div className="voting-date">{utils.formatMatchDateFull(match.date)}</div>
                        <div className="voting-note">üí° Vota tutti i giocatori eccetto te stesso</div>
                    </div>
                </div>

                <div className="voting-content">
                    {!hasVoted && (
                        <>
                            {/* SQUADRA GIALLI */}
                            <div className="team-voting-section">
                                <h3 className="team-section-title gialli">üü° GIALLI</h3>
                                {gialliToVote.map(player => (
                                    <div key={player.playerId} className="vote-row">
                                        <div className="vote-row-name">
                                            {player.playerName}
                                            {player.isGoalkeeper && ' üß§'}
                                        </div>
                                        <input
                                            type="range"
                                            min="1"
                                            max="10"
                                            step="0.5"
                                            value={votes[player.playerId] || DEFAULT_VOTE_VALUE}
                                            onChange={(e) => handleVoteChange(player.playerId, e.target.value)}
                                            className="vote-slider"
                                        />
                                        <div className="vote-value">
                                            {votes[player.playerId] ? votes[player.playerId].toFixed(1) : DEFAULT_VOTE_VALUE.toFixed(1)}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            {/* SQUADRA VERDI */}
                            <div className="team-voting-section">
                                <h3 className="team-section-title verdi">üü¢ VERDI</h3>
                                {verdiToVote.map(player => (
                                    <div key={player.playerId} className="vote-row">
                                        <div className="vote-row-name">
                                            {player.playerName}
                                            {player.isGoalkeeper && ' üß§'}
                                        </div>
                                        <input
                                            type="range"
                                            min="1"
                                            max="10"
                                            step="0.5"
                                            value={votes[player.playerId] || DEFAULT_VOTE_VALUE}
                                            onChange={(e) => handleVoteChange(player.playerId, e.target.value)}
                                            className="vote-slider"
                                        />
                                        <div className="vote-value">
                                            {votes[player.playerId] ? votes[player.playerId].toFixed(1) : DEFAULT_VOTE_VALUE.toFixed(1)}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </>
                    )}

                    {hasVoted && (
                        <>
                            {/* VOTI GI√Ä INVIATI */}
                            <div className="team-voting-section">
                                <h3 className="team-section-title gialli">üü° GIALLI</h3>
                                {gialliToVote.map(player => (
                                    <div key={player.playerId} className="vote-row readonly">
                                        <div className="vote-row-name">
                                            {player.playerName}
                                            {player.isGoalkeeper && ' üß§'}
                                        </div>
                                        <div className="vote-readonly-value">
                                            {votes[player.playerId] ? votes[player.playerId].toFixed(1) : '-'}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="team-voting-section">
                                <h3 className="team-section-title verdi">üü¢ VERDI</h3>
                                {verdiToVote.map(player => (
                                    <div key={player.playerId} className="vote-row readonly">
                                        <div className="vote-row-name">
                                            {player.playerName}
                                            {player.isGoalkeeper && ' üß§'}
                                        </div>
                                        <div className="vote-readonly-value">
                                            {votes[player.playerId] ? votes[player.playerId].toFixed(1) : '-'}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            {canModify && (
                                <div className="deadline-msg">
                                    Puoi modificare fino a prima di {utils.formatDeadlineDisplay(match.votingDeadline)}.
                                </div>
                            )}

                            {isLocked && (
                                <div className="deadline-msg closed">
                                    Le votazioni sono chiuse! 
                                </div>
                            )}
                        </>
                    )}

                    <div className="btn-group">
                        <button className="btn btn-secondary" onClick={onBack}>
                            ‚Üê INDIETRO
                        </button>
                        {!hasVoted && (
                            <button 
                                className="btn btn-primary" 
                                onClick={handleSubmit}
                                disabled={!isComplete() || submitting}
                            >
                                {submitting ? 'Invio...' : '‚úì INVIA VOTI'}
                            </button>
                        )}
                        {canModify && (
                            <button className="btn btn-primary" onClick={handleModify}>
                                ‚úèÔ∏è MODIFICA VOTI
                            </button>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
}

		

// ============================================================================
// ROUTER DETTAGLIO PARTITA
// ============================================================================

function MatchDetailRouter({ matchId, currentUser, onBack }) {
    const [match, setMatch] = React.useState(null);
    const [loading, setLoading] = React.useState(true);
    const [users, setUsers] = React.useState([]);  // üÜï AGGIUNGI

    React.useEffect(() => {
        loadMatch();
        loadUsers();  // üÜï AGGIUNGI
    }, [matchId]);

    const loadUsers = async () => {  // üÜï AGGIUNGI FUNZIONE
        try {
            const allUsers = await storage.getUsers();
            setUsers(allUsers);
        } catch (error) {
            console.error('Errore caricamento utenti:', error);
        }
    };

const loadMatch = async () => {
    setLoading(true);
    try {
        let data = await storage.getMatch(matchId);
        
        // Controlla e aggiorna status automaticamente
        data = await storage.checkAndUpdateMatchStatus(data);
        
        setMatch(data);
    } catch (error) {
        console.error('Errore caricamento partita:', error);
    }
    setLoading(false);
};

    if (loading) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>Caricamento...</h2>
                </div>
            </div>
        );
    }

    if (!match) {
        return (
            <div className="section-container">
                <div className="no-votes">
                    <h3>Partita non trovata</h3>
                    <button className="btn btn-secondary" onClick={onBack}>
                        ‚Üê Torna alle Partite
                    </button>
                </div>
            </div>
        );
    }

    // Router: quale vista mostrare in base allo status?
    if (match.status === 'OPEN' || match.status === 'CLOSED') {
return (
    <MatchRegistrationView 
        match={match} 
        currentUser={currentUser}
        users={users}
        onBack={onBack}
        onUpdate={loadMatch}
    />
);
    }

if (match.status === 'VOTING') {
    return (
        <MatchVotingView 
            match={match} 
            currentUser={currentUser}
            users={users}
            onBack={onBack}
        />
    );
}

    // COMPLETED - Vista Risultati
    return <MatchResultsView match={match} users={users} onBack={onBack} />;
}

// ============================================================================
// VISTA RISULTATI PARTITA COMPLETED  
// ============================================================================

function MatchResultsView({ match, users, onBack }) {
    const [matchVotes, setMatchVotes] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        loadMatchVotes();
    }, [match.id]);

    const loadMatchVotes = async () => {
        setLoading(true);
        try {
            const votes = await storage.getMatchVotes(match.id);
            setMatchVotes(votes);
        } catch (error) {
            console.error('Errore caricamento voti partita:', error);
        }
        setLoading(false);
    };

    // Calcola la media voti per ogni giocatore
    const calculatePlayerAverage = (playerId) => {
        const playerVotes = matchVotes
            .map(v => v.votes[playerId])
            .filter(v => v !== undefined);
        
        if (playerVotes.length === 0) return null;
        return playerVotes.reduce((a, b) => a + b, 0) / playerVotes.length;
    };

    // Conta quanti voti ha ricevuto un giocatore
    const getVoteCount = (playerId) => {
        return matchVotes.filter(v => v.votes[playerId] !== undefined).length;
    };

    // Crea classifica MVP
    const getMVPRanking = () => {
        const allPlayers = [...match.teams.gialli, ...match.teams.verdi];
        
        return allPlayers
            .map(player => ({
                ...player,
                avgVote: calculatePlayerAverage(player.playerId),
                voteCount: getVoteCount(player.playerId),
                team: match.teams.gialli.find(p => p.playerId === player.playerId) ? 'gialli' : 'verdi'
            }))
            .filter(p => p.avgVote !== null)
            .sort((a, b) => b.avgVote - a.avgVote);
    };

    // Calcola media squadra
    const getTeamAverage = (team) => {
        const teamPlayers = match.teams[team];
        const averages = teamPlayers
            .map(p => calculatePlayerAverage(p.playerId))
            .filter(avg => avg !== null);
        
        if (averages.length === 0) return null;
        return averages.reduce((a, b) => a + b, 0) / averages.length;
    };

    if (loading) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>Caricamento risultati...</h2>
                </div>
            </div>
        );
    }

    const mvpRanking = getMVPRanking();
    const gialliAvg = getTeamAverage('gialli');
    const verdiAvg = getTeamAverage('verdi');

    return (
        <div className="section-container">
            <div className="results-card">
                {/* HEADER RISULTATO */}
                <div className="results-header">
                    <span className="match-status completed">‚úÖ PARTITA CONCLUSA</span>

                    <div className="results-score">
                        <div className="results-team gialli">
                            <span className="team-name">GIALLI</span>
                            <span className="team-score">{match.score.gialli}</span>
                            {gialliAvg && (
                                <span className="team-avg">Avg: {gialliAvg.toFixed(2)}</span>
                            )}
                        </div>
                        
                        <span className="score-divider">-</span>
                        
                        <div className="results-team verdi">
                            <span className="team-name">VERDI</span>
                            <span className="team-score">{match.score.verdi}</span>
                            {verdiAvg && (
                                <span className="team-avg">Avg: {verdiAvg.toFixed(2)}</span>
                            )}
                        </div>
                    </div>

                    <div className="results-info">
                        <div className="results-date">{utils.formatMatchDateFull(match.date)}</div>
                        {match.topScorer && (
                            <div className="results-top-scorer">
                                üèÜ Capocannoniere: {match.topScorer} ({match.topScorerGoals} gol)
                            </div>
                        )}
                    </div>
                </div>

                {/* CLASSIFICA MVP */}
                <div className="results-content">
                    <h3 style={{textAlign: 'center', color: 'var(--volt)', marginBottom: '20px'}}>
                        ‚≠ê CLASSIFICA MVP DELLA PARTITA
                    </h3>

                    {mvpRanking.length === 0 ? (
                        <div className="no-votes">
                            <p>Nessun voto disponibile per questa partita</p>
                        </div>
                    ) : (
                        <div className="mvp-ranking">
                            {mvpRanking.map((player, index) => (
                                <div 
                                    key={player.playerId}
                                    className={`mvp-item ${index < 3 ? `mvp-rank-${index + 1}` : ''}`}
                                >
                                    <div className="mvp-rank">
                                        {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}
                                    </div>
                                    
                                    <div className="mvp-player-info">
                                        <div className="mvp-player-name">
                                            {player.playerName}
                                            {player.isGoalkeeper && ' üß§'}
                                        </div>
                                        <div className="mvp-player-team">
                                            {player.team === 'gialli' ? 'üü° Gialli' : 'üü¢ Verdi'}
                                        </div>
                                    </div>

                                    <div className="mvp-stats">
                                        <div className="mvp-vote">{player.avgVote.toFixed(2)}</div>
                                        <div className="mvp-vote-count">({player.voteCount} voti)</div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {/* STATISTICHE SQUADRE */}
                    <div style={{marginTop: '40px'}}>
                        <h3 style={{textAlign: 'center', color: 'var(--volt)', marginBottom: '20px'}}>
                            üìä STATISTICHE SQUADRE
                        </h3>

                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
                            gap: '20px'
                        }}>
                            {/* SQUADRA GIALLI */}
                            <div style={{
                                background: 'rgba(255, 215, 0, 0.1)',
                                border: '2px solid #FFD700',
                                borderRadius: '8px',
                                padding: '20px'
                            }}>
                                <h4 style={{
                                    color: '#FFD700',
                                    fontSize: '1.3rem',
                                    marginBottom: '15px',
                                    textAlign: 'center'
                                }}>
                                    üü° GIALLI
                                </h4>
                                <div style={{display: 'flex', flexDirection: 'column', gap: '10px'}}>
                                    {match.teams.gialli.map(player => {
                                        const avg = calculatePlayerAverage(player.playerId);
                                        return (
                                            <div key={player.playerId} style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center',
                                                padding: '8px',
                                                background: 'rgba(255, 255, 255, 0.05)',
                                                borderRadius: '4px'
                                            }}>
                                                <span>
                                                    {player.playerName}
                                                    {player.isGoalkeeper && ' üß§'}
                                                </span>
                                                <span style={{
                                                    fontWeight: 'bold',
                                                    color: avg && avg >= 7 ? '#48bb78' : avg && avg >= 6 ? '#f59e0b' : '#f56565'
                                                }}>
                                                    {avg ? avg.toFixed(2) : '-'}
                                                </span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                            {/* SQUADRA VERDI */}
                            <div style={{
                                background: 'rgba(72, 187, 120, 0.1)',
                                border: '2px solid #48bb78',
                                borderRadius: '8px',
                                padding: '20px'
                            }}>
                                <h4 style={{
                                    color: '#48bb78',
                                    fontSize: '1.3rem',
                                    marginBottom: '15px',
                                    textAlign: 'center'
                                }}>
                                    üü¢ VERDI
                                </h4>
                                <div style={{display: 'flex', flexDirection: 'column', gap: '10px'}}>
                                    {match.teams.verdi.map(player => {
                                        const avg = calculatePlayerAverage(player.playerId);
                                        return (
                                            <div key={player.playerId} style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center',
                                                padding: '8px',
                                                background: 'rgba(255, 255, 255, 0.05)',
                                                borderRadius: '4px'
                                            }}>
                                                <span>
                                                    {player.playerName}
                                                    {player.isGoalkeeper && ' üß§'}
                                                </span>
                                                <span style={{
                                                    fontWeight: 'bold',
                                                    color: avg && avg >= 7 ? '#48bb78' : avg && avg >= 6 ? '#f59e0b' : '#f56565'
                                                }}>
                                                    {avg ? avg.toFixed(2) : '-'}
                                                </span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="btn-group" style={{marginTop: '30px'}}>
                        <button className="btn btn-secondary" onClick={onBack}>
                            ‚Üê TORNA ALLE PARTITE
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}
		
		
        function PlayersListPage({ users, currentUser, votes, onSelectPlayer }) {
    const hasVoted = (playerId) => {
        return votes.some(v => v.voterId === currentUser.id && v.playerId === playerId);
    };
    
    const playersToVote = users.filter(u => {
        if (u.id === currentUser.id || u.id.startsWith('seed')) return false;
        if (hasVoted(u.id)) return false;
        if (currentUser.hasVotedOffline && u.isInitialPlayer) return false;
        return true;
    });

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>Seleziona un giocatore da valutare</h2>
            </div>
            
            {playersToVote.length === 0 ? (
                <div className="no-votes">
                    <h3>üéâ Ottimo lavoro, hai valutato tutti!</h3>
                    {currentUser.hasVotedOffline && <p>Hai gi√† votato tutti. Potrai votare i nuovi iscritti.</p>}
                </div>
            ) : (
                <div className="players-grid">
                    {playersToVote.map(player => (
                        <div key={player.id} className="player-card" onClick={() => onSelectPlayer(player.id)}>
                            <div className="avatar">{player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}</div>
<h3>{player.name} {player.isGoalkeeper && 'üß§'}</h3>
<div className="status">
    {player.isGoalkeeper && <span className="goalkeeper-badge">üß§ PORTIERE</span>}
    {!player.isInitialPlayer && <span className="new-badge">‚≠ê NUOVO</span>}
                                <div>Clicca per valutare</div>
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}

function RatingForm({ player, onSubmit, onCancel }) {
    const [ratings, setRatings] = useState({});
    const playerSkills = getSkillsForPlayer(player);

    const isComplete = () => {
        const allSkills = [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche];
                return allSkills.every(skill => ratings[skill]);
            };

            const handleSubmit = () => {
                if (isComplete()) { onSubmit(player.id, ratings); } 
                else { alert('Completa tutte le valutazioni prima di inviare'); }
            };

            return (
                <div className="rating-form">
                    <div className="form-header">
                        <div className="avatar">{player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}</div>
<h2>Valuta {player.name} {player.isGoalkeeper && 'üß§'}</h2>
                        <p>Scala: 1=Scarso | 2=Sufficiente | 3=Buono | 4=Ottimo</p>
                    </div>
{Object.entries(playerSkills).map(([category, skills]) => (             
	<div key={category} className="category-section">
                            <div className={`category-title category-${category}`}>{category.charAt(0).toUpperCase() + category.slice(1)}</div>
                            {skills.map(skill => (
                                <div key={skill} className="skill-item">
                                    <div className="skill-name">{skill}</div>
                                    <div className="rating-buttons">
                                        {[1, 2, 3, 4].map(value => (
                                            <button key={value} className={`rating-btn ${ratings[skill] === value ? 'selected' : ''}`} onClick={() => setRatings(prev => ({...prev, [skill]: value}))}>
                                                {value}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    ))}
                    <div className="form-actions">
                        <button className="btn btn-secondary" onClick={onCancel}>Annulla</button>
                        <button className="btn btn-primary" onClick={handleSubmit} disabled={!isComplete()}>‚úì Invia Valutazione</button>
                    </div>
                </div>
            );
        }

        function RadarChart({ data, labels, shortLabels, category }) {
            const canvasRef = useRef(null);

            useEffect(() => {
                if (!canvasRef.current || !data) return;
                const ctx = canvasRef.current.getContext('2d');
                if (canvasRef.current.chart) { canvasRef.current.chart.destroy(); }

                const colors = {
                    tecniche: 'rgba(102, 126, 234, 0.6)',
                    tattiche: 'rgba(72, 187, 120, 0.6)',
                    fisiche: 'rgba(245, 101, 101, 0.6)'
                };
                const borderColors = {
                    tecniche: 'rgb(102, 126, 234)',
                    tattiche: 'rgb(72, 187, 120)',
                    fisiche: 'rgb(245, 101, 101)'
                };

                canvasRef.current.chart = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: shortLabels,
                        datasets: [{
                            label: category.charAt(0).toUpperCase() + category.slice(1),
                            data: labels.map(label => utils.toBase10(data[label])),
                            backgroundColor: colors[category],
                            borderColor: borderColors[category],
                            borderWidth: 2,
                            pointBackgroundColor: borderColors[category],
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: borderColors[category]
                        }]
                    },
                    options: {
                        scales: { 
                            r: { 
                                beginAtZero: true, 
                                max: 10, 
                                min: 0, 
                                ticks: { 
                                    stepSize: 2,
                                    color: 'rgba(255, 255, 255, 0.5)',
                                    backdropColor: 'transparent'
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)',
                                    circular: true
                                },
                                angleLines: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                pointLabels: {
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    font: {
                                        size: 11
                                    }
                                }
                            } 
                        },
                        plugins: { legend: { display: false } }
                    }
                });

                return () => { if (canvasRef.current?.chart) { canvasRef.current.chart.destroy(); } };
            }, [data, labels, category]);

            return <canvas ref={canvasRef} className="chart-canvas"></canvas>;
        }

function PlayerProfile({ player, votes, isOwnProfile }) {
    const playerVotes = votes.filter(v => v.playerId === player.id);
    const voteCount = playerVotes.length;
    const hasEnoughVotes = voteCount >= 5;
const averages = utils.calculateAverages(player.id, votes, player);
    const overall = utils.calculateOverall(averages);
    const [flippedCard, setFlippedCard] = useState(null);
	   const playerSkills = getSkillsForPlayer(player);

    const handleCardClick = (category) => {
        if (window.innerWidth <= 768) {
            setFlippedCard(flippedCard === category ? null : category);
        }
    };

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>Profilo Giocatore</h2>
            </div>
            
            <div className="profile-header">
                <div className="avatar profile-avatar">
                    {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                </div>
                
                <div className="profile-header-info">
<h2>{player.name} {player.isGoalkeeper && 'üß§'}</h2>
                    <div className="votes-count">Sulla base di {voteCount} valutazioni ricevute</div>
                </div>
                
                {(player.preferredRole || (player.otherRoles && player.otherRoles.length > 0)) && (
                    <div className="role-info">
                        {player.preferredRole && (
                            <div className="role-item">
                                <div className="role-label">Ruolo preferito</div>
                                <div className="role-value">{player.preferredRole}</div>
                            </div>
                        )}
                        {player.otherRoles && player.otherRoles.length > 0 && (
                            <div className="role-item">
                                <div className="role-label">Mi adatto anche a</div>
                                <div className="role-badges">
                                    {player.otherRoles.map(role => (<span key={role} className="role-badge">{role}</span>))}
                                </div>
                            </div>
                        )}
                    </div>
                )}
            </div>

            {hasEnoughVotes && overall && (
                <div className="overall-container">
                    <div className="overall-main">{utils.toBase10(overall).toFixed(2)}</div>
                    <div className="overall-label">Overall Rating</div>
                </div>
            )}

            {hasEnoughVotes && averages ? (
                <div className="charts-container">
    {Object.entries(getSkillsForPlayer(player)).map(([category, skills]) => {
        
        const shortSkills = getShortSkillsForPlayer(player)[category];  
        const catOverall = utils.calculateCategoryOverall(averages, category, player);

        return (
            <div 
                key={category} 
                className={`chart-box ${flippedCard === category ? 'flipped' : ''}`}
                onClick={() => handleCardClick(category)}
            >
                <div className="chart-box-inner">
                    
                    {/* FRONT (Radar) */}
                    <div className="chart-box-front">
                        <h3 className={`category-${category}`}>
                            {category.charAt(0).toUpperCase() + category.slice(1)}
                        </h3>

                        {catOverall && (
                            <div className="category-overall">
                                {utils.toBase10(catOverall).toFixed(2)}
                            </div>
                        )}

                        <RadarChart 
    data={averages}
    labels={skills}         // skill estese ‚Üí per i valori
    shortLabels={shortSkills} // abbreviazioni ‚Üí per visualizzare
    category={category}
/>
                    </div>

                    {/* BACK (Lista dettagliata con label estese) */}
                    <div className="chart-box-back">
                        <h4 className={`category-${category}`}>
                            {category.charAt(0).toUpperCase() + category.slice(1)}
                        </h4>
                        <div className="chart-detail-list">
                            {skills.map(skill => (
                                <div key={skill} className="chart-detail-item">
                                    <span>{skill}</span> {/* <-- estesa */}
                                    <span className={`category-${category}`}>
                                        {averages[skill]
                                            ? utils.toBase10(averages[skill]).toFixed(2)
                                            : '-'}
                                    </span>
                                </div>
                            ))}
                        </div>
                    </div>

                </div>
            </div>
        );
    })}
</div>
			)
 : (
                <div className="no-votes">
                    <h3>üìä Grafici non disponibili</h3>
                    <p>{isOwnProfile ? "Chiedi ai tuoi compagni di valutarti!" : "Questo giocatore ha bisogno di pi√π valutazioni"}</p>
                    <p>Servono almeno 5 valutazioni (attualmente: {voteCount})</p>
                </div>
            )}
        </div>
    );
}

function ClassifichePage({ users, votes, currentUser, onViewProfile }) {
    const [view, setView] = useState('main'); // 'main' | 'macro-detail' | 'skill-detail'
    const [selectedMacro, setSelectedMacro] = useState(null);
    const [selectedSkill, setSelectedSkill] = useState(null);
    const [showAllOverall, setShowAllOverall] = useState(false);
    const [showAllMacro, setShowAllMacro] = useState({ tecniche: false, tattiche: false, fisiche: false });

// Scroll to top quando cambia la vista
useEffect(() => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
}, [view, selectedMacro, selectedSkill]);
	
    // Conta i voti fatti dall'utente corrente
    const userVotesCount = votes.filter(v => v.voterId === currentUser.id).length;
    const canViewLeaderboard = userVotesCount >= 5;
    
    // Calcola statistiche overall
const playersWithOverall = users
    .filter(u => !u.id.startsWith('seed'))
    .map(player => {
        const averages = utils.calculateAverages(player.id, votes, player);
        const overall = utils.calculateOverall(averages);
        const voteCount = utils.countVotes(player.id, votes);
        return { ...player, overall, voteCount, averages };
    })
    .filter(p => p.overall !== null && p.voteCount >= 3)
    .sort((a, b) => b.overall - a.overall);

    // Funzione per calcolare classifica per macrocategoria
    const getPlayersForMacro = (macroCategory) => {
        return users
            .filter(u => !u.id.startsWith('seed'))
            .map(player => {
                const averages = utils.calculateAverages(player.id, votes, player);
                const voteCount = utils.countVotes(player.id, votes);
                
                // Controllo null-safety
                if (!averages) {
                    return { ...player, score: null, voteCount };
                }
                
                const skillsForCategory = player.isGoalkeeper 
                    ? SKILLS_GOALKEEPER[macroCategory]
                    : SKILLS[macroCategory];
                
                // Controllo che skillsForCategory esista
                if (!skillsForCategory) {
                    return { ...player, score: null, voteCount };
                }
                
                const categoryVotes = skillsForCategory.map(skill => averages[skill]).filter(v => v !== undefined);
                const categoryAvg = categoryVotes.length > 0 
                    ? categoryVotes.reduce((a, b) => a + b, 0) / categoryVotes.length 
                    : null;
                
                return { ...player, score: categoryAvg, voteCount };
            })
            .filter(p => p.score !== null && p.voteCount >= 3)
            .sort((a, b) => b.score - a.score);
    };

    // Funzione per calcolare classifica per skill specifica
    const getPlayersForSkill = (skillName) => {
        return users
            .filter(u => !u.id.startsWith('seed'))
            .map(player => {
                const averages = utils.calculateAverages(player.id, votes, player);
                const voteCount = utils.countVotes(player.id, votes);
                const score = averages ? averages[skillName] : undefined;
                
                return { ...player, score, voteCount };
            })
            .filter(p => p.score !== undefined && p.voteCount >= 3)
            .sort((a, b) => b.score - a.score);
    };

    // Handler per apertura dettaglio macro
    const openMacroDetail = (macro) => {
        setSelectedMacro(macro);
        setView('macro-detail');
    };

    // Handler per apertura dettaglio skill
    const openSkillDetail = (skill, category) => {
        setSelectedSkill({ name: skill, category });
        setView('skill-detail');
    };

    // Handler per tornare indietro
    const goBack = () => {
        setView('main');
        setSelectedMacro(null);
        setSelectedSkill(null);
    };

    // Se non ha votato abbastanza
    if (!canViewLeaderboard) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>üìä Classifiche</h2>
                </div>
                
                <div className="no-votes">
                    <h3>üîí Classifica Bloccata</h3>
                    <p>Per visualizzare le classifiche devi completare almeno 5 valutazioni</p>
                    <p style={{marginTop: '15px', fontSize: '1.2rem', color: 'var(--volt)'}}>
                        Hai completato: <strong>{userVotesCount}/5</strong> valutazioni
                    </p>
                    <p style={{marginTop: '10px', opacity: '0.8'}}>
                        Vai alla sezione "Valuta" per votare altri giocatori!
                    </p>
                </div>
            </div>
        );
    }

    // Se non ci sono dati
    if (playersWithOverall.length === 0) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>üìä Classifiche</h2>
                </div>
                <div className="no-votes">
                    <h3>Nessuna classifica disponibile</h3>
                    <p>I giocatori devono ricevere almeno 5 valutazioni per apparire</p>
                </div>
            </div>
        );
    }

    // ==================== VISTA DETTAGLIO MACROCATEGORIA ====================
    if (view === 'macro-detail' && selectedMacro) {
        const playersForMacro = getPlayersForMacro(selectedMacro);
        const macroInfo = {
            tecniche: { emoji: 'üéØ', title: 'Abilit√† Tecniche', color: '#FF2E63' },
            tattiche: { emoji: 'üß†', title: 'Abilit√† Tattiche', color: '#00F0FF' },
            fisiche: { emoji: 'üí™', title: 'Abilit√† Fisiche', color: '#D2F800' }
        };
        const info = macroInfo[selectedMacro];

        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>{info.emoji} {info.title}</h2>
                    <button className="btn-back" onClick={goBack}>‚Üê Indietro</button>
                </div>

                <div className="leaderboard-container">
                    {playersForMacro.map((player, index) => (
                        <div 
                            key={player.id}
                            className={`leaderboard-item ${index < 3 ? `rank-${index + 1}` : ''}`}
                            onClick={() => onViewProfile(player.id)}
                        >
                            <div className="rank-number">
                                {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}
                            </div>
                            <div className="avatar">
                                {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                            </div>
                            <div style={{flex: 1}}>
                                <div style={{fontWeight: '600', fontSize: '18px'}}>{player.name} {player.isGoalkeeper && 'üß§'}</div>
                                <div style={{fontSize: '13px', opacity: 0.8}}>{player.voteCount} valutazioni</div>
                            </div>
                            <div style={{fontWeight: '800', fontSize: '28px'}}>{utils.toBase10(player.score).toFixed(2)}</div>
                        </div>
                    ))}
                </div>
            </div>
        );
    }

    // ==================== VISTA DETTAGLIO SKILL ====================
    if (view === 'skill-detail' && selectedSkill) {
        const playersForSkill = getPlayersForSkill(selectedSkill.name);
        const skillEmojis = {
            'Tiro': '‚ö°', 'Passaggio corto': 'üì®', 'Passaggio lungo': 'üì°', 'Contrasto': 'üõ°Ô∏è', 'Controllo': '‚öΩ',
            'Visione di gioco': 'üëÅÔ∏è', 'Senso della posizione': 'üìç', 'Spirito di sacrificio': 'üí™', 
            'Letture difensive': 'üõ°Ô∏è', 'Costruzione': 'üèóÔ∏è',
            'Resistenza': 'üèÉ', 'Scatto': '‚ö°', 'Progressione': 'üöÄ', 'Presenza fisica': 'ü¶Å', 'Cazzimma': 'üî•'
        };
        const emoji = skillEmojis[selectedSkill.name] || '‚≠ê';

        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>{emoji} {selectedSkill.name}</h2>
                    <button className="btn-back" onClick={goBack}>‚Üê Indietro</button>
                </div>

                <div className="leaderboard-container">
                    {playersForSkill.map((player, index) => (
                        <div 
                            key={player.id}
                            className={`leaderboard-item ${index < 3 ? `rank-${index + 1}` : ''}`}
                            onClick={() => onViewProfile(player.id)}
                        >
                            <div className="rank-number">
                                {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}
                            </div>
                            <div className="avatar">
                                {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                            </div>
                            <div style={{flex: 1}}>
                                <div style={{fontWeight: '600', fontSize: '18px'}}>{player.name} {player.isGoalkeeper && 'üß§'}</div>
                                <div style={{fontSize: '13px', opacity: 0.8}}>{player.voteCount} valutazioni</div>
                            </div>
                            <div style={{fontWeight: '800', fontSize: '28px'}}>{utils.toBase10(player.score).toFixed(2)}</div>
                        </div>
                    ))}
                </div>
            </div>
        );
    }

    // ==================== VISTA PRINCIPALE ====================
    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üìä Classifiche Complete</h2>
            </div>

            {/* 1Ô∏è‚É£ CLASSIFICA OVERALL */}
            <div className="rankings-overall-section">
                <h3 className="rankings-section-title">üèÜ Classifica Generale</h3>
                
                <div className="leaderboard-container">
                    {playersWithOverall.slice(0, showAllOverall ? undefined : 5).map((player, index) => (
                        <div 
                            key={player.id}
                            className={`leaderboard-item ${index < 3 ? `rank-${index + 1}` : ''}`}
                            onClick={() => onViewProfile(player.id)}
                        >
                            <div className="rank-number">
                                {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}
                            </div>
                            <div className="avatar">
                                {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                            </div>
                            <div style={{flex: 1}}>
                                <div style={{fontWeight: '600', fontSize: '18px'}}>{player.name} {player.isGoalkeeper && 'üß§'}</div>
                                <div style={{fontSize: '13px', opacity: 0.8}}>{player.voteCount} valutazioni</div>
                            </div>
                            <div style={{fontWeight: '800', fontSize: '28px'}}>{utils.toBase10(player.overall).toFixed(2)}</div>
                        </div>
                    ))}
                </div>

                {playersWithOverall.length > 5 && (
                    <button 
                        className="btn-expand" 
                        onClick={() => setShowAllOverall(!showAllOverall)}
                    >
                        {showAllOverall ? '‚¨ÜÔ∏è Mostra meno' : `‚¨áÔ∏è Mostra altri ${playersWithOverall.length - 5}`}
                    </button>
                )}
            </div>

            {/* 2Ô∏è‚É£ MACROCATEGORIE */}
            <h3 className="rankings-section-title" style={{marginTop: '40px'}}>üìà Classifiche per Macrocategoria</h3>
            
            <div className="rankings-macro-grid">
                {/* TECNICA */}
                <div className="rankings-macro-card rankings-macro-tecnica" onClick={() => openMacroDetail('tecniche')}>
                    <div className="rankings-macro-header">
                        <span className="rankings-macro-emoji">üéØ</span>
                        <span className="rankings-macro-title">Tecnica</span>
                    </div>
                    
                    <div className="rankings-compact-list">
                        {getPlayersForMacro('tecniche').slice(0, showAllMacro.tecniche ? undefined : 3).map((player, index) => (
                            <div key={player.id} className="rankings-compact-item" onClick={(e) => { e.stopPropagation(); onViewProfile(player.id); }}>
                                <div className="rank-number">{index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}</div>
                                <div className="avatar-small">
                                    {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                                </div>
                                <div style={{flex: 1, minWidth: 0}}>
                                    <div style={{fontWeight: '600', fontSize: '15px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap'}}>
                                        {player.name} {player.isGoalkeeper && 'üß§'}
                                    </div>
                                </div>
                                <div style={{fontWeight: '800', fontSize: '20px'}}>{utils.toBase10(player.score).toFixed(2)}</div>
                            </div>
                        ))}
                    </div>

                    {getPlayersForMacro('tecniche').length > 3 && (
                        <button 
                            className="btn-expand-small" 
                            onClick={(e) => { e.stopPropagation(); setShowAllMacro({...showAllMacro, tecniche: !showAllMacro.tecniche}); }}
                        >
                            {showAllMacro.tecniche ? '‚¨ÜÔ∏è Mostra meno' : `‚¨áÔ∏è Mostra tutti (${getPlayersForMacro('tecniche').length})`}
                        </button>
                    )}
                </div>

                {/* TATTICA */}
                <div className="rankings-macro-card rankings-macro-tattica" onClick={() => openMacroDetail('tattiche')}>
                    <div className="rankings-macro-header">
                        <span className="rankings-macro-emoji">üß†</span>
                        <span className="rankings-macro-title">Tattica</span>
                    </div>
                    
                    <div className="rankings-compact-list">
                        {getPlayersForMacro('tattiche').slice(0, showAllMacro.tattiche ? undefined : 3).map((player, index) => (
                            <div key={player.id} className="rankings-compact-item" onClick={(e) => { e.stopPropagation(); onViewProfile(player.id); }}>
                                <div className="rank-number">{index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}</div>
                                <div className="avatar-small">
                                    {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                                </div>
                                <div style={{flex: 1, minWidth: 0}}>
                                    <div style={{fontWeight: '600', fontSize: '15px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap'}}>
                                        {player.name} {player.isGoalkeeper && 'üß§'}
                                    </div>
                                </div>
                                <div style={{fontWeight: '800', fontSize: '20px'}}>{utils.toBase10(player.score).toFixed(2)}</div>
                            </div>
                        ))}
                    </div>

                    {getPlayersForMacro('tattiche').length > 3 && (
                        <button 
                            className="btn-expand-small" 
                            onClick={(e) => { e.stopPropagation(); setShowAllMacro({...showAllMacro, tattiche: !showAllMacro.tattiche}); }}
                        >
                            {showAllMacro.tattiche ? '‚¨ÜÔ∏è Mostra meno' : `‚¨áÔ∏è Mostra tutti (${getPlayersForMacro('tattiche').length})`}
                        </button>
                    )}
                </div>

                {/* FISICA */}
                <div className="rankings-macro-card rankings-macro-fisica" onClick={() => openMacroDetail('fisiche')}>
                    <div className="rankings-macro-header">
                        <span className="rankings-macro-emoji">üí™</span>
                        <span className="rankings-macro-title">Fisica</span>
                    </div>
                    
                    <div className="rankings-compact-list">
                        {getPlayersForMacro('fisiche').slice(0, showAllMacro.fisiche ? undefined : 3).map((player, index) => (
                            <div key={player.id} className="rankings-compact-item" onClick={(e) => { e.stopPropagation(); onViewProfile(player.id); }}>
                                <div className="rank-number">{index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}</div>
                                <div className="avatar-small">
                                    {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                                </div>
                                <div style={{flex: 1, minWidth: 0}}>
                                    <div style={{fontWeight: '600', fontSize: '15px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap'}}>
                                        {player.name} {player.isGoalkeeper && 'üß§'}
                                    </div>
                                </div>
                                <div style={{fontWeight: '800', fontSize: '20px'}}>{utils.toBase10(player.score).toFixed(2)}</div>
                            </div>
                        ))}
                    </div>

                    {getPlayersForMacro('fisiche').length > 3 && (
                        <button 
                            className="btn-expand-small" 
                            onClick={(e) => { e.stopPropagation(); setShowAllMacro({...showAllMacro, fisiche: !showAllMacro.fisiche}); }}
                        >
                            {showAllMacro.fisiche ? '‚¨ÜÔ∏è Mostra meno' : `‚¨áÔ∏è Mostra tutti (${getPlayersForMacro('fisiche').length})`}
                        </button>
                    )}
                </div>
            </div>

            {/* 3Ô∏è‚É£ SKILL INDIVIDUALI */}
<h3 className="rankings-section-title" style={{marginTop: '40px'}}>‚ö° Top 3 per ogni Skill</h3>

<div className="rankings-skills-grid">
    {Object.keys(SKILLS).flatMap(category => 
        SKILLS[category].map((skill, idx) => {
            const playersForSkill = getPlayersForSkill(skill);
            const skillEmojis = {
                'Tiro': '‚ö°', 'Passaggio corto': 'üì®', 'Passaggio lungo': 'üì°', 'Contrasto': 'üõ°Ô∏è', 'Controllo': '‚öΩ',
                'Visione di gioco': 'üëÅÔ∏è', 'Senso della posizione': 'üìç', 'Spirito di sacrificio': 'üí™', 
                'Letture difensive': 'üõ°Ô∏è', 'Costruzione': 'üóùÔ∏è',
                'Resistenza': 'üèÉ', 'Scatto': '‚ö°', 'Progressione': 'üöÄ', 'Presenza fisica': 'ü¶Å', 'Cazzimma': 'üî•'
            };
            const emoji = skillEmojis[skill] || '‚≠ê';

            return (
                <div key={skill} className="rankings-skill-card" onClick={() => openSkillDetail(skill, category)}>
                    <div className="rankings-skill-title">{emoji} {skill}</div>
                    
                    <div className="rankings-mini-list">
                        {playersForSkill.slice(0, 3).map((player, index) => (
                            <div key={player.id} className="rankings-mini-item" onClick={(e) => { e.stopPropagation(); onViewProfile(player.id); }}>
                                <div className="rank-mini">{index + 1}</div>
                                <div className="avatar-mini">
                                    {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                                </div>
                                <div style={{flex: 1, minWidth: 0, fontSize: '14px', fontWeight: '600', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap'}}>
                                    {player.name}
                                </div>
                                <div style={{fontWeight: '800', fontSize: '16px'}}>{utils.toBase10(player.score).toFixed(2)}</div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        })
    )}
</div>
        </div>
    );
}
function SettingsPage({ user, onUpdateUser }) {
    const [showSuccess, setShowSuccess] = useState(false);
    const [showRoleEdit, setShowRoleEdit] = useState(false);

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onloadend = async () => {
                const updatedUser = { ...user, avatar: reader.result };
                await onUpdateUser(updatedUser);
                setShowSuccess(true);
                setTimeout(() => setShowSuccess(false), 3000);
            };
            reader.readAsDataURL(file);
        }
    };

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>‚öôÔ∏è Impostazioni</h2>
            </div>
            
            <div className="settings-group">
                <h3>Foto Profilo</h3>
                <div className="settings-info">
                    <div className="settings-avatar">
                        {user.avatar ? <img src={user.avatar} alt={user.name} /> : utils.getInitials(user.name)}
                    </div>
                    <div className="file-input-wrapper">
                        <input type="file" id="avatar-upload" accept="image/*" onChange={handleFileChange} />
                        <label htmlFor="avatar-upload" className="file-input-label">üì∑ Carica Foto</label>
                    </div>
                </div>
            </div>

            <div className="settings-group">
                <h3>Informazioni Account</h3>
                <div className="settings-info-box">
                    <div style={{marginBottom: '15px'}}><strong>Nome:</strong> {user.name}</div>
                    <div><strong>Email:</strong> {user.email}</div>
                </div>
            </div>

            <div className="settings-group">
                <h3>Ruoli</h3>
                <div className="settings-info-box">
                    <div style={{marginBottom: '15px'}}>
                        <strong>Ruolo preferito:</strong> {user.preferredRole || 'Non impostato'}
                    </div>
                    <div style={{marginBottom: '15px'}}>
                        <strong>Altri ruoli:</strong>
                        <div style={{marginTop: '8px'}}>
                            {user.otherRoles && user.otherRoles.length > 0 ? (
                                <div className="role-badges">
                                    {user.otherRoles.map(role => (
                                        <span key={role} className="role-badge">{role}</span>
                                    ))}
                                </div>
                            ) : (
                                <span style={{color: '#718096'}}>Nessuno</span>
                            )}
                        </div>
                    </div>
                    <button className="btn btn-secondary" onClick={() => setShowRoleEdit(true)} style={{marginTop: '10px'}}>
                        ‚úèÔ∏è Modifica Ruoli
                    </button>
                </div>
            </div>

            {showSuccess && <div className="success-message">‚úì Impostazioni aggiornate!</div>}

            {showRoleEdit && (
                <RoleEditModal 
                    user={user}
                    onClose={() => setShowRoleEdit(false)}
                    onSuccess={async () => { 
                        const updatedUser = await storage.getUsers().then(users => users.find(u => u.id === user.id));
                        await onUpdateUser(updatedUser);
                        setShowRoleEdit(false); 
                        setShowSuccess(true); 
                        setTimeout(() => setShowSuccess(false), 3000); 
                    }}
                />
            )}
        </div>
    );
}



function AdminPage({ users, setUsers, votes, setVotes }) {
    const [editingPlayer, setEditingPlayer] = useState(null);
    const [editName, setEditName] = useState('');
    const [showSuccess, setShowSuccess] = useState(false);
    const [successMessage, setSuccessMessage] = useState('');
    const [editingVotes, setEditingVotes] = useState(null);
    const [voteValues, setVoteValues] = useState({});
	const [showPlayersList, setShowPlayersList] = useState(false);


// === STATI PER GESTIONE PARTITE ===
    const [showCreateMatch, setShowCreateMatch] = useState(false);
    const [newMatchDate, setNewMatchDate] = useState('');
    const [newMatchTime, setNewMatchTime] = useState('21:20');
    const [newMatchLocation, setNewMatchLocation] = useState('Campo SuperSantos, Portici');
    const [newMatchMaxPlayers, setNewMatchMaxPlayers] = useState(18);
    const [adminMatches, setAdminMatches] = useState([]);
    const [adminRegistrations, setAdminRegistrations] = useState({});
    
    // üÜï STATI PER ASSEGNAZIONE SQUADRE E RISULTATO
    const [showTeamAssignment, setShowTeamAssignment] = useState(false);
    const [selectedMatchForTeams, setSelectedMatchForTeams] = useState(null);
    const [teamGialli, setTeamGialli] = useState([]);
    const [teamVerdi, setTeamVerdi] = useState([]);
    const [showScoreModal, setShowScoreModal] = useState(false);
    const [selectedMatchForScore, setSelectedMatchForScore] = useState(null);
    const [scoreGialli, setScoreGialli] = useState('');
    const [scoreVerdi, setScoreVerdi] = useState('');
    const [topScorer, setTopScorer] = useState('');
    const [topScorerGoals, setTopScorerGoals] = useState('');
    
    // üÜï STATI PER MODIFICA MAX PLAYERS
    const [editingMaxPlayers, setEditingMaxPlayers] = useState(null);
    const [newMaxPlayers, setNewMaxPlayers] = useState('');

    // Carica partite all'avvio
    useEffect(() => {
        loadAdminMatches();
    }, []);

const loadAdminMatches = async () => {
    try {
        console.log('üîÑ Caricamento partite admin...');
        const matches = await storage.getMatches();
        console.log('üì• Partite caricate:', matches.length);
        
        // Controlla e aggiorna status automaticamente
        const updatedMatches = await Promise.all(
            matches.map(match => storage.checkAndUpdateMatchStatus(match))
        );
        
        console.log('‚úÖ Partite aggiornate:', updatedMatches);
        
        // Verifica che le squadre ci siano
        updatedMatches.forEach(match => {
            if (match.teams) {
                console.log(`Match ${match.id} - Teams:`, match.teams);
            }
        });
        
        setAdminMatches(updatedMatches);
        
        // Carica iscrizioni per ogni partita
        const regsMap = {};
        for (const match of updatedMatches) {
            const regs = await storage.getRegistrations(match.id);
            regsMap[match.id] = regs;
        }
        setAdminRegistrations(regsMap);
    } catch (error) {
        console.error('‚ùå Errore caricamento partite admin:', error);
    }
};

    const handleCreateMatch = async () => {
        if (!newMatchDate || !newMatchTime || !newMatchLocation) {
            alert('Compila tutti i campi obbligatori');
            return;
        }

        try {
            // Costruisci data completa
            const matchDateTime = new Date(`${newMatchDate}T${newMatchTime}:00`);
            
            // Deadline display: 3 giorni prima alle 18:00
            const regDeadlineDisplay = new Date(matchDateTime);
            regDeadlineDisplay.setDate(regDeadlineDisplay.getDate() - 3);
            regDeadlineDisplay.setHours(18, 0, 0, 0);
            
            // Deadline forzata: 50 minuti prima della partita
            const regDeadlineForced = new Date(matchDateTime);
            regDeadlineForced.setMinutes(regDeadlineForced.getMinutes() - 50);
            
            // Deadline voti: 3 giorni dopo a mezzanotte
            const votingDeadline = new Date(matchDateTime);
            votingDeadline.setDate(votingDeadline.getDate() + 3);
            votingDeadline.setHours(23, 59, 59, 999);

            await storage.createMatch({
                date: matchDateTime.toISOString(),
                location: newMatchLocation,
                maxPlayers: parseInt(newMatchMaxPlayers),
                registrationDeadlineDisplay: regDeadlineDisplay.toISOString(),
                registrationDeadlineForced: regDeadlineForced.toISOString(),
                votingDeadline: votingDeadline.toISOString()
            });

            // Reset form
            setNewMatchDate('');
            setNewMatchTime('21:20');
            setNewMatchLocation('Campo SuperSantos, Portici');
            setNewMatchMaxPlayers(18);
            setShowCreateMatch(false);
            
            showSuccessMsg('Partita creata!');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore creazione partita:', error);
            alert('Errore durante la creazione della partita');
        }
    };

const handleCloseRegistrations = async (matchId) => {
    if (!confirm('Chiudere le iscrizioni? I giocatori non potranno pi√π iscriversi.')) return;
    
    try {
        await storage.updateMatch(matchId, { 
            status: 'CLOSED',
            manualOverride: false,  // üëà AGGIUNTO: reset override
            manualOverrideUntil: null
        });
            showSuccessMsg('Iscrizioni chiuse!');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore chiusura iscrizioni:', error);
            alert('Errore durante la chiusura');
        }
    };

    // üÜï RIAPRI ISCRIZIONI
    const handleReopenRegistrations = async (matchId) => {
    const match = adminMatches.find(m => m.id === matchId);
    if (!match) return;
    
    let confirmMessage = '';
    let resetData = {};
    
    if (match.status === 'CLOSED') {
    console.log('üü° Caso rilevato: CLOSED');
    confirmMessage = 'Riaprire le iscrizioni? Le squadre NON verranno cancellate.';
    resetData = { 
        status: 'OPEN',
        manualOverride: true,  // üëà AGGIUNTO
        manualOverrideUntil: Date.now() + (2 * 60 * 60 * 1000)  // 2 ore di protezione
    };
} else if (match.status === 'VOTING') {
    console.log('üü° Caso rilevato: VOTING');
    confirmMessage = '‚ö†Ô∏è Tornare alle iscrizioni? ATTENZIONE: Le squadre e i voti verranno cancellati!';
    resetData = { 
        status: 'OPEN',
        teams: { gialli: [], verdi: [] },
        score: null,
        topScorer: null,
        topScorerGoals: null,
        manualOverride: true,  // üëà AGGIUNTO
        manualOverrideUntil: Date.now() + (2 * 60 * 60 * 1000)
    };
} else if (match.status === 'COMPLETED') {
    console.log('üü° Caso rilevato: COMPLETED');
    confirmMessage = '‚ö†Ô∏è Riaprire la partita? ATTENZIONE: Risultato e voti verranno cancellati!';
    resetData = { 
        status: 'OPEN',
        teams: { gialli: [], verdi: [] },
        score: { gialli: 0, verdi: 0 },
        topScorer: null,
        topScorerGoals: null,
        manualOverride: true,  // üëà AGGIUNTO
        manualOverrideUntil: Date.now() + (2 * 60 * 60 * 1000)
    };
}
    
    if (!confirm(confirmMessage)) return;
    
    try {
        // Se √® VOTING o COMPLETED, cancella i voti
        if (match.status === 'VOTING' || match.status === 'COMPLETED') {
            const votesSnapshot = await db.collection('matches')
                .doc(matchId)
                .collection('match_votes')
                .get();
            
            const batch = db.batch();
            votesSnapshot.docs.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
        }
        
await storage.updateMatch(matchId, resetData);
await loadAdminMatches();
showSuccessMsg('‚úÖ Partita riaperta!');
    } catch (error) {
        console.error('Errore:', error);
        alert('Errore durante la riapertura');
    }
};

    // üÜï MODIFICA MAX PLAYERS
    const handleEditMaxPlayers = (matchId, currentMax) => {
        setEditingMaxPlayers(matchId);
        setNewMaxPlayers(currentMax.toString());
    };

    const handleSaveMaxPlayers = async (matchId) => {
        const maxPlayers = parseInt(newMaxPlayers);
        
        // Validazione: deve essere pari e tra 10 e 20
        if (isNaN(maxPlayers) || maxPlayers < 10 || maxPlayers > 20 || maxPlayers % 2 !== 0) {
            alert('Il numero deve essere pari e compreso tra 10 e 20 (10, 12, 14, 16, 18, 20)');
            return;
        }
        
        try {
            await storage.updateMatch(matchId, { maxPlayers: maxPlayers });
            setEditingMaxPlayers(null);
            setNewMaxPlayers('');
            showSuccessMsg('Numero massimo aggiornato!');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore aggiornamento max players:', error);
            alert('Errore durante l\'aggiornamento');
        }
    };

    const handleDeleteMatch = async (matchId) => {
        if (!confirm('‚ö†Ô∏è ATTENZIONE: Eliminare questa partita e tutte le iscrizioni?')) return;
        if (!confirm('Conferma: sei sicuro di voler eliminare tutto?')) return;
        
        try {
            await storage.deleteMatch(matchId);
            showSuccessMsg('Partita eliminata!');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore eliminazione partita:', error);
            alert('Errore durante l\'eliminazione');
        }
    };

    // üÜï GESTIONE ASSEGNAZIONE SQUADRE
    const handleOpenTeamAssignment = async (matchId) => {
        const match = adminMatches.find(m => m.id === matchId);
        const regs = adminRegistrations[matchId] || [];
        
        if (regs.length < 2) {
            alert('Servono almeno 2 giocatori iscritti per assegnare le squadre');
            return;
        }
        
        setSelectedMatchForTeams(match);
        
        // Se gi√† ci sono squadre, caricale
        if (match.teams && match.teams.gialli && match.teams.gialli.length > 0) {
            setTeamGialli(match.teams.gialli);
            setTeamVerdi(match.teams.verdi);
        } else {
            // Altrimenti genera squadre bilanciate
            generateBalancedTeams(regs);
        }
        
        setShowTeamAssignment(true);
    };

    const generateBalancedTeams = (registrations) => {
        // 1. Carica i dati dei giocatori dal database users
        const playersWithData = registrations.map(reg => {
            const userData = users.find(u => u.id === reg.playerId);
            const averages = utils.calculateAverages(reg.playerId, votes, userData);
            const overall = utils.calculateOverall(averages) || 2.5; // Default medio se nessun voto
            
            return {
                ...reg,
                overall: overall,
                preferredRole: userData?.preferredRole || null,
                otherRoles: userData?.otherRoles || []
            };
        });
        
        // 2. Separa portieri e giocatori di movimento
        const goalkeepers = playersWithData.filter(p => p.isGoalkeeper);
        const fieldPlayers = playersWithData.filter(p => !p.isGoalkeeper);
        
        // 3. Ordina giocatori per overall (dal pi√π forte al pi√π debole)
        const sortedPlayers = [...fieldPlayers].sort((a, b) => b.overall - a.overall);
        
        // 4. Inizializza squadre
        let gialli = [];
        let verdi = [];
        
        // 5. Distribuisci portieri (uno per squadra se possibile)
        if (goalkeepers.length >= 2) {
            // Ordina portieri per overall
            const sortedGK = [...goalkeepers].sort((a, b) => b.overall - a.overall);
            gialli.push(sortedGK[0]);
            verdi.push(sortedGK[1]);
            // Se ci sono pi√π di 2 portieri, aggiungili alternando
            for (let i = 2; i < sortedGK.length; i++) {
                if (i % 2 === 0) gialli.push(sortedGK[i]);
                else verdi.push(sortedGK[i]);
            }
        } else if (goalkeepers.length === 1) {
            // Un solo portiere va nei gialli (o random)
            gialli.push(goalkeepers[0]);
        }
        
        // 6. Distribuisci giocatori con algoritmo "snake draft" per bilanciare overall
        // Alterna: gialli, verdi, verdi, gialli, gialli, verdi...
        let teamIndex = 0; // 0 = gialli, 1 = verdi
        let direction = 1; // 1 = avanti, -1 = indietro
        
        for (let i = 0; i < sortedPlayers.length; i++) {
            if (teamIndex === 0) {
                gialli.push(sortedPlayers[i]);
            } else {
                verdi.push(sortedPlayers[i]);
            }
            
            // Cambia squadra
            teamIndex += direction;
            
            // Se arriviamo all'estremo, inverti direzione (snake)
            if (teamIndex > 1) {
                teamIndex = 1;
                direction = -1;
            } else if (teamIndex < 0) {
                teamIndex = 0;
                direction = 1;
            }
        }
        
        // 7. Bilancia numericamente (assicura stesso numero o differenza max 1)
        while (Math.abs(gialli.length - verdi.length) > 1) {
            if (gialli.length > verdi.length) {
                // Sposta il giocatore pi√π debole da gialli a verdi
                const weakest = gialli.reduce((min, p) => p.overall < min.overall ? p : min);
                gialli = gialli.filter(p => p.playerId !== weakest.playerId);
                verdi.push(weakest);
            } else {
                // Sposta il giocatore pi√π debole da verdi a gialli
                const weakest = verdi.reduce((min, p) => p.overall < min.overall ? p : min);
                verdi = verdi.filter(p => p.playerId !== weakest.playerId);
                gialli.push(weakest);
            }
        }
        
        setTeamGialli(gialli);
        setTeamVerdi(verdi);
    };
    
    // üÜï FUNZIONE PER CALCOLARE STATISTICHE SQUADRA
    const calculateTeamStats = (team) => {
        if (!team || team.length === 0) return { avgOverall: 0, totalOverall: 0, goalkeepers: 0 };
        
        const totalOverall = team.reduce((sum, p) => {
            const userData = users.find(u => u.id === p.playerId);
            const averages = utils.calculateAverages(p.playerId, votes, userData);
            const overall = utils.calculateOverall(averages) || 2.5;
            return sum + overall;
        }, 0);
        
        const avgOverall = totalOverall / team.length;
        const goalkeepers = team.filter(p => p.isGoalkeeper).length;
        
        return {
            avgOverall: avgOverall,
            totalOverall: totalOverall,
            goalkeepers: goalkeepers,
            count: team.length
        };
    };

    const movePlayerToTeam = (player, fromTeam, toTeam) => {
        if (fromTeam === 'gialli') {
            setTeamGialli(teamGialli.filter(p => p.playerId !== player.playerId));
            setTeamVerdi([...teamVerdi, player]);
        } else {
            setTeamVerdi(teamVerdi.filter(p => p.playerId !== player.playerId));
            setTeamGialli([...teamGialli, player]);
        }
    };

    const handleSaveTeams = async () => {
        if (teamGialli.length === 0 || teamVerdi.length === 0) {
            alert('Entrambe le squadre devono avere almeno un giocatore');
            return;
        }
        
        console.log('üíæ Salvataggio squadre...');
        console.log('Match ID:', selectedMatchForTeams.id);
        console.log('Gialli:', teamGialli);
        console.log('Verdi:', teamVerdi);
        
        try {
            const teamsData = {
                gialli: teamGialli,
                verdi: teamVerdi
            };
            
            console.log('üì§ Invio dati:', teamsData);
            
            await storage.updateMatch(selectedMatchForTeams.id, {
                teams: teamsData
            });
            
            console.log('‚úÖ Squadre salvate con successo!');
            
            showSuccessMsg('Squadre assegnate!');
            setShowTeamAssignment(false);
            setSelectedMatchForTeams(null);
            setTeamGialli([]);
            setTeamVerdi([]);
            await loadAdminMatches();
        } catch (error) {
            console.error('‚ùå Errore salvataggio squadre:', error);
            alert('Errore durante il salvataggio: ' + error.message);
        }
    };

    // üÜï GESTIONE RISULTATO
const handleOpenScoreModal = (matchId) => {
   
    const match = adminMatches.find(m => m.id === matchId);
    
    if (!match) {
        console.error('‚ùå Match non trovato!');
        alert('‚ùå Errore: Partita non trovata!');
        return;
    }
    
    if (!match.teams || !match.teams.gialli || match.teams.gialli.length === 0) {
        console.error('‚ùå Squadre non assegnate correttamente!');
        alert('‚ùå Devi prima assegnare le squadre!');
        return;
    }
    
    console.log('‚úÖ Squadre OK, apro modal...');
    setSelectedMatchForScore(match);

// Se gi√† c'√® un risultato, caricalo (con controlli sicuri)
if (match.score && typeof match.score.gialli !== 'undefined' && typeof match.score.verdi !== 'undefined') {
    console.log('‚úÖ Carico score esistente:', match.score);
    setScoreGialli(match.score.gialli.toString());
    setScoreVerdi(match.score.verdi.toString());
} else {
    console.log('‚ÑπÔ∏è Nessuno score da caricare, inizializzo vuoto');
    setScoreGialli('');
    setScoreVerdi('');
}

if (match.topScorer) {
    console.log('‚úÖ Carico topScorer esistente:', match.topScorer);
    setTopScorer(match.topScorer);
    setTopScorerGoals(match.topScorerGoals?.toString() || '');
} else {
    console.log('‚ÑπÔ∏è Nessun topScorer da caricare');
    setTopScorer('');
    setTopScorerGoals('');
}

console.log('‚úÖ Apro modal risultato');
setShowScoreModal(true);
    };

    const handleSaveScore = async () => {
        if (!scoreGialli || !scoreVerdi) {
            alert('Inserisci entrambi i punteggi');
            return;
        }
        
        const gialliScore = parseInt(scoreGialli);
        const verdiScore = parseInt(scoreVerdi);
        
        if (isNaN(gialliScore) || isNaN(verdiScore) || gialliScore < 0 || verdiScore < 0) {
            alert('Inserisci punteggi validi');
            return;
        }
        
        try {
            const updates = {
                score: {
                    gialli: gialliScore,
                    verdi: verdiScore
                }
            };
            
            // Aggiungi capocannoniere se presente
            if (topScorer && topScorerGoals) {
                updates.topScorer = topScorer;
                updates.topScorerGoals = parseInt(topScorerGoals);
            }
            
            await storage.updateMatch(selectedMatchForScore.id, updates);
            
            showSuccessMsg('Risultato salvato!');
            setShowScoreModal(false);
            setSelectedMatchForScore(null);
            setScoreGialli('');
            setScoreVerdi('');
            setTopScorer('');
            setTopScorerGoals('');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore salvataggio risultato:', error);
            alert('Errore durante il salvataggio');
        }
    };




	
    const showSuccessMsg = (msg) => {
        setSuccessMessage(msg);
        setShowSuccess(true);
        setTimeout(() => setShowSuccess(false), 3000);
    };

    const handleEditName = (player) => {
        setEditingPlayer(player.id);
        setEditName(player.name);
    };

    const handleSaveName = async (playerId) => {
        if (!editName.trim()) return;
        const updatedUser = users.find(u => u.id === playerId);
        updatedUser.name = editName.trim();
        await storage.updateUser(updatedUser);
        const updatedUsers = users.map(u => u.id === playerId ? updatedUser : u);
        setUsers(updatedUsers);
        setEditingPlayer(null);
        setEditName('');
        showSuccessMsg('Nome aggiornato!');
    };

    const handleDeletePlayer = async (playerId) => {
        if (!confirm('Eliminare questo giocatore e tutte le sue valutazioni?')) return;
        const updatedUsers = users.filter(u => u.id !== playerId);
        setUsers(updatedUsers);
        await storage.setUsers(updatedUsers);
        showSuccessMsg('Giocatore eliminato!');
    };

    const handleEditVotes = (player) => {
const averages = utils.calculateAverages(player.id, votes, player);
		if (averages) {
            const values = {};
            Object.keys(averages).forEach(k => { values[k] = averages[k].toFixed(2); });
            setVoteValues(values);
        } else {
            const emptyValues = {};
            [...SKILLS.tecniche, ...SKILLS.tattiche, ...SKILLS.fisiche].forEach(skill => { emptyValues[skill] = ''; });
            setVoteValues(emptyValues);
        }
        setEditingVotes(player);
    };

    const handleSaveVotes = async () => {
        for (let i = 0; i < 8; i++) {
            const seedVote = { 
                voterId: `seed_admin_${i}_${Date.now()}`, 
                playerId: editingVotes.id, 
                ratings: {}, 
                timestamp: Date.now() 
            };
            [...SKILLS.tecniche, ...SKILLS.tattiche, ...SKILLS.fisiche].forEach(skill => {
                const value = parseFloat(voteValues[skill]);
                if (!isNaN(value)) seedVote.ratings[skill] = Math.round(value);
            });
            await storage.addVote(seedVote);
        }
        setEditingVotes(null);
        setVoteValues({});
        showSuccessMsg('Valutazioni aggiornate!');
        setTimeout(() => window.location.reload(), 1000);
    };

    const handleAddPlayer = async () => {
        const newName = prompt('Nome del nuovo giocatore:');
        if (!newName || !newName.trim()) return;
        const newPlayer = { id: `player${Date.now()}`, name: newName.trim(), avatar: null, preferredRole: null, otherRoles: [], email: null, claimed: false, isAdmin: false };
        await storage.updateUser(newPlayer);
        setUsers([...users, newPlayer]);
        showSuccessMsg('Giocatore aggiunto!');
    };

    const handleFullReset = () => {
        if (!confirm('‚ö†Ô∏è ATTENZIONE: Eliminare TUTTI i dati?')) return;
        if (!confirm('Conferma: vuoi davvero cancellare tutto?')) return;
        storage.clearAll();
        window.location.reload();
    };

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üîß Pannello Amministratore</h2>
            </div>

            {showSuccess && <div className="success-message">‚úì {successMessage}</div>}

			<div className="settings-group">
                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px'}}>
                    <h3>üèÜ Gestione Partite</h3>
                    <button className="btn btn-primary" onClick={() => setShowCreateMatch(!showCreateMatch)}>
                        {showCreateMatch ? '‚úï Annulla' : '+ Crea Partita'}
                    </button>
                </div>

                {showCreateMatch && (
                    <div className="admin-create-match">
                        <h4>Crea Nuova Partita</h4>
                        
                        <div className="form-group">
                            <label>Data Partita *</label>
                            <input 
                                type="date" 
                                value={newMatchDate}
                                onChange={(e) => setNewMatchDate(e.target.value)}
                            />
                        </div>

                        <div className="form-group">
                            <label>Orario *</label>
                            <input 
                                type="time" 
                                value={newMatchTime}
                                onChange={(e) => setNewMatchTime(e.target.value)}
                            />
                        </div>

                        <div className="form-group">
                            <label>Location *</label>
                            <input 
                                type="text" 
                                value={newMatchLocation}
                                onChange={(e) => setNewMatchLocation(e.target.value)}
                                placeholder="Es: Campo SuperSantos, Portici"
                            />
                        </div>

                        <div className="form-group">
                            <label>Max Giocatori (numero pari: 10, 12, 14, 16, 18, 20)</label>
                            <select 
                                value={newMatchMaxPlayers}
                                onChange={(e) => setNewMatchMaxPlayers(e.target.value)}
                            >
                                <option value="10">10 giocatori (5 vs 5)</option>
                                <option value="12">12 giocatori (6 vs 6)</option>
                                <option value="14">14 giocatori (7 vs 7)</option>
                                <option value="16">16 giocatori (8 vs 8)</option>
                                <option value="18">18 giocatori (9 vs 9)</option>
                                <option value="20">20 giocatori (10 vs 10)</option>
                            </select>
                        </div>

                        <button 
                            className="btn btn-primary" 
                            onClick={handleCreateMatch}
                            disabled={!newMatchDate || !newMatchTime || !newMatchLocation}
                        >
                            ‚úì Crea Partita
                        </button>
                    </div>
                )}

                <div className="admin-matches-list">
                    {adminMatches.map(match => {
                        const regs = adminRegistrations[match.id] || [];
                        return (
                            <div key={match.id} className="admin-match-item">
                                <div className="admin-match-header">
                                    <span className={`match-status ${match.status.toLowerCase()}`}>
                                        {match.status === 'OPEN' && 'üìù APERTA'}
                                        {match.status === 'CLOSED' && 'üîí CHIUSA'}
                                        {match.status === 'VOTING' && '‚≠ê VOTAZIONI'}
                                        {match.status === 'COMPLETED' && '‚úÖ FINITA'}
                                    </span>
                                    <span className="admin-match-date">{utils.formatMatchDate(match.date)}</span>
                                </div>
                                
                                <div className="admin-match-info">
                                    <span>üìç {match.location}</span>
                                    {editingMaxPlayers === match.id ? (
                                        <div style={{display: 'flex', alignItems: 'center', gap: '8px'}}>
                                            <span>üë•</span>
                                            <select 
                                                value={newMaxPlayers}
                                                onChange={(e) => setNewMaxPlayers(e.target.value)}
                                                style={{
                                                    background: 'var(--bg-deep)',
                                                    color: 'white',
                                                    border: '1px solid var(--volt)',
                                                    padding: '4px 8px',
                                                    borderRadius: '4px',
                                                    fontSize: '13px'
                                                }}
                                            >
                                                <option value="10">10</option>
                                                <option value="12">12</option>
                                                <option value="14">14</option>
                                                <option value="16">16</option>
                                                <option value="18">18</option>
                                                <option value="20">20</option>
                                            </select>
                                            <button 
                                                onClick={() => handleSaveMaxPlayers(match.id)}
                                                style={{
                                                    background: '#48bb78',
                                                    border: 'none',
                                                    padding: '4px 8px',
                                                    borderRadius: '4px',
                                                    cursor: 'pointer',
                                                    color: 'white',
                                                    fontSize: '12px'
                                                }}
                                            >
                                                ‚úì
                                            </button>
                                            <button 
                                                onClick={() => {
                                                    setEditingMaxPlayers(null);
                                                    setNewMaxPlayers('');
                                                }}
                                                style={{
                                                    background: '#718096',
                                                    border: 'none',
                                                    padding: '4px 8px',
                                                    borderRadius: '4px',
                                                    cursor: 'pointer',
                                                    color: 'white',
                                                    fontSize: '12px'
                                                }}
                                            >
                                                ‚úï
                                            </button>
                                        </div>
                                    ) : (
                                        <span 
                                            onClick={() => handleEditMaxPlayers(match.id, match.maxPlayers)}
                                            style={{cursor: 'pointer', textDecoration: 'underline'}}
                                            title="Click per modificare"
                                        >
                                            üë• {regs.length}/{match.maxPlayers}
                                        </span>
                                    )}
                                </div>

                                <div className="admin-match-actions">
                                    {match.status === 'OPEN' && (
                                        <button 
                                            className="admin-action-btn close"
                                            onClick={() => handleCloseRegistrations(match.id)}
                                        >
                                            üîí Chiudi Iscrizioni
                                        </button>
                                    )}
                                    {match.status === 'CLOSED' && (
                                        <>
                                            <button 
                                                className="admin-action-btn reopen"
                                                onClick={() => handleReopenRegistrations(match.id)}
                                            >
                                                üîì Riapri Iscrizioni
                                            </button>
                                            <button 
                                                className="admin-action-btn assign"
                                                onClick={() => handleOpenTeamAssignment(match.id)}
                                            >
                                                üë• Assegna Squadre
                                            </button>
                                            <button 
                                                className="admin-action-btn score"
                                                onClick={() => handleOpenScoreModal(match.id)}
                                            >
                                                                ‚öΩ Inserisci Risultato
            </button>
        </>
    )}
    {match.status === 'VOTING' && (
        <>
            <button 
                className="admin-action-btn reopen"
                onClick={() => handleReopenRegistrations(match.id)}
            >
                üîô Torna a Iscrizioni
            </button>
            <button 
                className="admin-action-btn score"
                onClick={() => handleOpenScoreModal(match.id)}
            >
                ‚öΩ Inserisci Risultato
            </button>
        </>
    )}
    {match.status === 'COMPLETED' && (
        <button 
            className="admin-action-btn reopen"
            onClick={() => handleReopenRegistrations(match.id)}
        >
            üîô Riapri Partita
        </button>
    )}
    <button 
        className="admin-action-btn delete"
        onClick={() => handleDeleteMatch(match.id)}
    >
        üóëÔ∏è Elimina
    </button>
</div>
                            </div>
                        );
                    })}
                </div>
            </div>

			
            <div className="settings-group">
    <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px'}}>
        <h3 style={{cursor: 'pointer', userSelect: 'none'}} onClick={() => setShowPlayersList(!showPlayersList)}>
            {showPlayersList ? '‚ñº' : '‚ñ∂'} üë• Gestione Giocatori ({users.filter(u => !u.id.startsWith('seed')).length})
        </h3>
        <div style={{display: 'flex', gap: '10px'}}>
            {showPlayersList && <button className="btn btn-primary" onClick={handleAddPlayer}>+ Aggiungi</button>}
            <button className="btn btn-secondary" onClick={() => setShowPlayersList(!showPlayersList)}>
                {showPlayersList ? 'Comprimi' : 'Espandi'}
            </button>
        </div>
    </div>
    
    {showPlayersList && (
        <div className="admin-player-list">
                    {users.filter(u => !u.id.startsWith('seed')).map((player, index) => {
                        const voteCount = utils.countVotes(player.id, votes);
                        const averages = utils.calculateAverages(player.id, votes);
                        const overall = utils.calculateOverall(averages);
                        
                        return (
                            <div key={player.id} className="admin-player-item">
                                <span style={{color: '#a0aec0', width: '25px'}}>{index + 1}.</span>
                                
                                {editingPlayer === player.id ? (
                                    <div style={{display: 'flex', gap: '10px', flex: 1}}>
                                        <input type="text" value={editName} onChange={(e) => setEditName(e.target.value)} className="admin-input" autoFocus />
                                        <button onClick={() => handleSaveName(player.id)} className="admin-btn btn-save">‚úì</button>
                                        <button onClick={() => setEditingPlayer(null)} className="admin-btn btn-cancel">‚úï</button>
                                    </div>
                                ) : (
                                    <>
                                        <span style={{fontWeight: '600', minWidth: '140px'}}>{player.name}</span>
                                        <span style={{color: '#718096', fontSize: '13px', flex: 1}}>{player.claimed ? `‚úì ${player.email}` : '‚óã Non reclamato'}</span>
                                        <span style={{color: '#667eea', fontSize: '13px'}}>OVR: {overall ? utils.toBase10(overall).toFixed(2) : '-'} ({voteCount} voti)</span>
                                        <div style={{display: 'flex', gap: '6px'}}>
                                            <button onClick={() => handleEditName(player)} className="admin-btn">‚úèÔ∏è</button>
                                            <button onClick={() => handleEditVotes(player)} className="admin-btn btn-chart">üìä</button>
                                            <button onClick={() => handleDeletePlayer(player.id)} className="admin-btn btn-delete">üóëÔ∏è</button>
                                        </div>
                                    </>
                                )}
                            </div>
                        );
                    })}
                </div>
    )}
</div>
            
            <div className="settings-group">
                <h3>üíæ Backup Database</h3>
                <p>Esporta o importa tutti i dati (utenti e voti) per fare backup o ripristinare</p>
                <div style={{display: 'flex', gap: '15px', marginTop: '15px'}}>
                    <button className="btn btn-primary" onClick={() => {
                        const data = { users, votes, timestamp: Date.now(), date: new Date().toISOString() };
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `calcetto_backup_${new Date().toISOString().split('T')[0]}.json`;
                        a.click();
                        showSuccessMsg('Backup esportato!');
                    }}>üì• Esporta Backup</button>
                    <button className="btn btn-secondary" onClick={() => {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.json';
                        input.onchange = async (e) => {
                            try {
                                const file = e.target.files[0];
                                const text = await file.text();
                                const data = JSON.parse(text);
                                if (!confirm('‚ö†Ô∏è ATTENZIONE: Questo sovrascriver√† tutti i dati attuali. Continuare?')) return;
                                if (data.users) await storage.setUsers(data.users);
                                if (data.votes) await storage.setVotes(data.votes);
                                showSuccessMsg('Backup importato!');
                                setTimeout(() => window.location.reload(), 1000);
                            } catch (err) {
                                alert('Errore durante l\'importazione: ' + err.message);
                            }
                        };
                        input.click();
                    }}>üì§ Importa Backup</button>
                </div>
            </div>


			
            <div className="settings-group admin-danger-zone">
                <h3>‚ö†Ô∏è Zona Pericolosa</h3>
                <p>Azioni irreversibili!</p>
                <button className="btn btn-danger" onClick={handleFullReset}>üóëÔ∏è Reset Completo</button>
            </div>

            {editingVotes && (
                <div className="modal-overlay">
                    <div className="modal-content modal-large">
                        <h2>üìä Modifica: {editingVotes.name}</h2>
                        <p>Inserisci valori 1-4. Verranno creati 8 voti seed.</p>
                        {['tecniche', 'tattiche', 'fisiche'].map(category => (
                            <div key={category} className="vote-edit-category">
                                <h4 className={`category-${category}`}>{category}</h4>
                                <div className="vote-edit-grid">
                                    {SKILLS[category].map(skill => (
                                        <div key={skill} className="vote-edit-item">
                                            <label>{skill}</label>
                                            <input type="number" min="1" max="4" step="0.01" value={voteValues[skill] || ''} onChange={(e) => setVoteValues({...voteValues, [skill]: e.target.value})} />
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                        <div className="modal-actions">
                            <button className="btn btn-secondary" onClick={() => setEditingVotes(null)}>Annulla</button>
                            <button className="btn btn-primary" onClick={handleSaveVotes}>Salva</button>
                        </div>
                    </div>
                </div>
            )}

            {/* üÜï MODALE ASSEGNAZIONE SQUADRE */}
            {showTeamAssignment && selectedMatchForTeams && (
                <div className="modal-overlay">
                    <div className="modal-content modal-large">
                        <h2>üë• Assegna Squadre - {utils.formatMatchDate(selectedMatchForTeams.date)}</h2>
                        <p>Trascina i giocatori tra le squadre o usa il bilanciamento automatico</p>

                        {/* üÜï STATISTICHE BILANCIAMENTO */}
                        {teamGialli.length > 0 && teamVerdi.length > 0 && (
                            <div style={{
                                background: 'rgba(210, 248, 0, 0.1)', 
                                border: '1px solid rgba(210, 248, 0, 0.3)',
                                borderRadius: '8px',
                                padding: '15px',
                                marginTop: '20px',
                                marginBottom: '10px'
                            }}>
                                <h4 style={{color: 'var(--volt)', marginBottom: '15px', textAlign: 'center'}}>
                                    üìä Statistiche Bilanciamento
                                </h4>
                                <div style={{display: 'flex', gap: '30px', justifyContent: 'center', flexWrap: 'wrap'}}>
                                    {(() => {
                                        const gialliStats = calculateTeamStats(teamGialli);
                                        const verdiStats = calculateTeamStats(teamVerdi);
                                        const diff = Math.abs(gialliStats.avgOverall - verdiStats.avgOverall);
                                        const isBalanced = diff < 0.3;
                                        
                                        return (
                                            <>
                                                <div style={{textAlign: 'center'}}>
                                                    <div style={{fontSize: '11px', color: '#a0aec0', marginBottom: '5px'}}>GIALLI</div>
                                                    <div style={{fontSize: '24px', fontWeight: 'bold', color: '#FFD700'}}>
                                                        {utils.toBase10(gialliStats.avgOverall).toFixed(2)}
                                                    </div>
                                                    <div style={{fontSize: '11px', color: '#a0aec0', marginTop: '3px'}}>
                                                        {gialliStats.count} giocatori | {gialliStats.goalkeepers} üß§
                                                    </div>
                                                </div>
                                                
                                                <div style={{
                                                    display: 'flex', 
                                                    flexDirection: 'column', 
                                                    justifyContent: 'center',
                                                    alignItems: 'center',
                                                    gap: '5px'
                                                }}>
                                                    <div style={{fontSize: '18px'}}>‚öñÔ∏è</div>
                                                    <div style={{
                                                        fontSize: '12px',
                                                        fontWeight: 'bold',
                                                        color: isBalanced ? '#48bb78' : '#f59e0b',
                                                        padding: '4px 10px',
                                                        background: isBalanced ? 'rgba(72, 187, 120, 0.2)' : 'rgba(245, 158, 11, 0.2)',
                                                        borderRadius: '12px'
                                                    }}>
                                                        {isBalanced ? '‚úì BILANCIATE' : `Œî ${utils.toBase10(diff).toFixed(2)}`}
                                                    </div>
                                                </div>
                                                
                                                <div style={{textAlign: 'center'}}>
                                                    <div style={{fontSize: '11px', color: '#a0aec0', marginBottom: '5px'}}>VERDI</div>
                                                    <div style={{fontSize: '24px', fontWeight: 'bold', color: '#48bb78'}}>
                                                        {utils.toBase10(verdiStats.avgOverall).toFixed(2)}
                                                    </div>
                                                    <div style={{fontSize: '11px', color: '#a0aec0', marginTop: '3px'}}>
                                                        {verdiStats.count} giocatori | {verdiStats.goalkeepers} üß§
                                                    </div>
                                                </div>
                                            </>
                                        );
                                    })()}
                                </div>
                            </div>
                        )}

                        <div style={{display: 'flex', gap: '20px', marginTop: '20px'}}>
                            {/* SQUADRA GIALLI */}
                            <div style={{flex: 1, background: 'rgba(255, 215, 0, 0.1)', padding: '15px', borderRadius: '8px', border: '2px solid #FFD700'}}>
                                <h3 style={{color: '#FFD700', marginBottom: '15px'}}>
                                    üü° GIALLI ({teamGialli.length})
                                </h3>
                                <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
                                    {teamGialli.map(player => {
                                        const userData = users.find(u => u.id === player.playerId);
                                        const averages = utils.calculateAverages(player.playerId, votes, userData);
                                        const overall = utils.calculateOverall(averages) || 2.5;
                                        
                                        return (
                                            <div 
                                                key={player.playerId}
                                                style={{
                                                    background: 'rgba(255, 255, 255, 0.05)',
                                                    padding: '10px',
                                                    borderRadius: '4px',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}
                                            >
                                                <div style={{display: 'flex', alignItems: 'center', gap: '10px'}}>
                                                    <span style={{
                                                        background: 'rgba(255, 215, 0, 0.2)',
                                                        padding: '2px 8px',
                                                        borderRadius: '4px',
                                                        fontSize: '12px',
                                                        fontWeight: 'bold',
                                                        color: '#FFD700',
                                                        minWidth: '40px',
                                                        textAlign: 'center'
                                                    }}>
                                                        {utils.toBase10(overall).toFixed(1)}
                                                    </span>
                                                    <span>
                                                        {player.playerName}
                                                        {player.isGoalkeeper && ' üß§'}
                                                    </span>
                                                </div>
                                                <button
                                                    onClick={() => movePlayerToTeam(player, 'gialli', 'verdi')}
                                                    style={{
                                                        background: '#48bb78',
                                                        border: 'none',
                                                        padding: '4px 12px',
                                                        borderRadius: '4px',
                                                        cursor: 'pointer',
                                                        fontSize: '12px',
                                                        color: 'white'
                                                    }}
                                                >
                                                    ‚Üí VERDI
                                                </button>
                                            </div>
                                        );
                                    })}
                                    {teamGialli.length === 0 && (
                                        <p style={{textAlign: 'center', opacity: 0.5}}>Nessun giocatore</p>
                                    )}
                                </div>
                            </div>

                            {/* SQUADRA VERDI */}
                            <div style={{flex: 1, background: 'rgba(72, 187, 120, 0.1)', padding: '15px', borderRadius: '8px', border: '2px solid #48bb78'}}>
                                <h3 style={{color: '#48bb78', marginBottom: '15px'}}>
                                    üü¢ VERDI ({teamVerdi.length})
                                </h3>
                                <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
                                    {teamVerdi.map(player => {
                                        const userData = users.find(u => u.id === player.playerId);
                                        const averages = utils.calculateAverages(player.playerId, votes, userData);
                                        const overall = utils.calculateOverall(averages) || 2.5;
                                        
                                        return (
                                            <div 
                                                key={player.playerId}
                                                style={{
                                                    background: 'rgba(255, 255, 255, 0.05)',
                                                    padding: '10px',
                                                    borderRadius: '4px',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}
                                            >
                                                <div style={{display: 'flex', alignItems: 'center', gap: '10px'}}>
                                                    <span style={{
                                                        background: 'rgba(72, 187, 120, 0.2)',
                                                        padding: '2px 8px',
                                                        borderRadius: '4px',
                                                        fontSize: '12px',
                                                        fontWeight: 'bold',
                                                        color: '#48bb78',
                                                        minWidth: '40px',
                                                        textAlign: 'center'
                                                    }}>
                                                        {utils.toBase10(overall).toFixed(1)}
                                                    </span>
                                                    <span>
                                                        {player.playerName}
                                                        {player.isGoalkeeper && ' üß§'}
                                                    </span>
                                                </div>
                                                <button
                                                    onClick={() => movePlayerToTeam(player, 'verdi', 'gialli')}
                                                    style={{
                                                        background: '#FFD700',
                                                        border: 'none',
                                                        padding: '4px 12px',
                                                        borderRadius: '4px',
                                                        cursor: 'pointer',
                                                        fontSize: '12px',
                                                        color: 'black'
                                                    }}
                                                >
                                                    ‚Üê GIALLI
                                                </button>
                                            </div>
                                        );
                                    })}
                                    {teamVerdi.length === 0 && (
                                        <p style={{textAlign: 'center', opacity: 0.5}}>Nessun giocatore</p>
                                    )}
                                </div>
                            </div>
                        </div>

                        <div style={{marginTop: '20px', textAlign: 'center'}}>
                            <button
                                className="btn btn-secondary"
                                onClick={() => generateBalancedTeams(adminRegistrations[selectedMatchForTeams.id] || [])}
                                style={{marginRight: '10px'}}
                            >
                                üîÑ Bilancia Automaticamente
                            </button>
                        </div>

                        <div className="modal-actions">
                            <button className="btn btn-secondary" onClick={() => {
                                setShowTeamAssignment(false);
                                setSelectedMatchForTeams(null);
                                setTeamGialli([]);
                                setTeamVerdi([]);
                            }}>
                                Annulla
                            </button>
                            <button className="btn btn-primary" onClick={handleSaveTeams}>
                                ‚úì Salva Squadre
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* üÜï MODALE RISULTATO */}
            {showScoreModal && selectedMatchForScore && (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>‚öΩ Inserisci Risultato - {utils.formatMatchDate(selectedMatchForScore.date)}</h2>
                        
                        <div style={{display: 'flex', gap: '20px', marginTop: '20px', alignItems: 'center', justifyContent: 'center'}}>
                            <div style={{textAlign: 'center'}}>
                                <label style={{display: 'block', color: '#FFD700', marginBottom: '8px', fontWeight: 'bold'}}>
                                    üü° GIALLI
                                </label>
                                <input
                                    type="number"
                                    min="0"
                                    value={scoreGialli}
                                    onChange={(e) => setScoreGialli(e.target.value)}
                                    style={{
                                        width: '80px',
                                        height: '60px',
                                        fontSize: '28px',
                                        textAlign: 'center',
                                        background: 'var(--bg-deep)',
                                        border: '2px solid #FFD700',
                                        color: 'white',
                                        borderRadius: '8px'
                                    }}
                                />
                            </div>

                            <span style={{fontSize: '32px', fontWeight: 'bold'}}>-</span>

                            <div style={{textAlign: 'center'}}>
                                <label style={{display: 'block', color: '#48bb78', marginBottom: '8px', fontWeight: 'bold'}}>
                                    üü¢ VERDI
                                </label>
                                <input
                                    type="number"
                                    min="0"
                                    value={scoreVerdi}
                                    onChange={(e) => setScoreVerdi(e.target.value)}
                                    style={{
                                        width: '80px',
                                        height: '60px',
                                        fontSize: '28px',
                                        textAlign: 'center',
                                        background: 'var(--bg-deep)',
                                        border: '2px solid #48bb78',
                                        color: 'white',
                                        borderRadius: '8px'
                                    }}
                                />
                            </div>
                        </div>

                        <div style={{marginTop: '30px'}}>
                            <h4 style={{marginBottom: '15px', color: 'var(--volt)'}}>üèÜ Capocannoniere (opzionale)</h4>
                            <div className="form-group">
                                <label>Nome Giocatore</label>
                                <input
                                    type="text"
                                    value={topScorer}
                                    onChange={(e) => setTopScorer(e.target.value)}
                                    placeholder="Es: Mario Rossi"
                                />
                            </div>
                            <div className="form-group">
                                <label>Numero Gol</label>
                                <input
                                    type="number"
                                    min="1"
                                    value={topScorerGoals}
                                    onChange={(e) => setTopScorerGoals(e.target.value)}
                                    placeholder="Es: 3"
                                />
                            </div>
                        </div>

                        <div className="modal-actions">
                            <button className="btn btn-secondary" onClick={() => {
                                setShowScoreModal(false);
                                setSelectedMatchForScore(null);
                                setScoreGialli('');
                                setScoreVerdi('');
                                setTopScorer('');
                                setTopScorerGoals('');
                            }}>
                                Annulla
                            </button>
                            <button className="btn btn-primary" onClick={handleSaveScore}>
                                ‚úì Salva Risultato
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}

function DebugPage({ users, votes }) {
    const [selectedPlayer, setSelectedPlayer] = useState(null);
    const [editingVote, setEditingVote] = useState(null);
    const [editVoteValues, setEditVoteValues] = useState({});

    const getVoteStats = (playerId) => {
        const playerVotes = votes.filter(v => v.playerId === playerId);
        const seedVotes = playerVotes.filter(v => v.voterId && v.voterId.startsWith('seed'));
        const realVotes = playerVotes.filter(v => v.voterId && !v.voterId.startsWith('seed'));
        return { total: playerVotes.length, seed: seedVotes.length, real: realVotes.length, allVotes: playerVotes };
    };

    const handleEditVote = (vote) => {
        setEditingVote(vote);
        setEditVoteValues(vote.ratings);
    };

    const handleSaveEditedVote = async () => {
        if (!editingVote.id) {
            alert('Impossibile modificare voti senza ID');
            return;
        }
        try {
            await db.collection('votes').doc(editingVote.id).update({ ratings: editVoteValues });
            alert('Voto aggiornato! Ricarica la pagina per vedere le modifiche.');
            setEditingVote(null);
        } catch (err) {
            alert('Errore durante il salvataggio: ' + err.message);
        }
    };

    const handleDeleteVote = async (voteId) => {
        if (!voteId) {
            alert('Impossibile eliminare voti senza ID');
            return;
        }
        if (!confirm('Eliminare questo voto?')) return;
        try {
            await db.collection('votes').doc(voteId).delete();
            alert('Voto eliminato! Ricarica la pagina.');
        } catch (err) {
            alert('Errore durante l\'eliminazione: ' + err.message);
        }
    };

    const players = users.filter(u => !u.id.startsWith('seed'));

if (selectedPlayer) {
    const player = players.find(p => p.id === selectedPlayer);
    if (!player) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>üêõ Debug - Giocatore non trovato</h2>
                    <button onClick={() => setSelectedPlayer(null)} className="btn-back">‚Üê Indietro</button>
                </div>
                <p>Giocatore con ID {selectedPlayer} non trovato</p>
            </div>
        );
    }
    const stats = getVoteStats(player.id);
    const averages = utils.calculateAverages(player.id, votes, player); // üÜï Passa player
        const overall = utils.calculateOverall(averages);

        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>üìä Dettaglio: {player.name}</h2>
                    <button onClick={() => setSelectedPlayer(null)} className="btn-back">‚Üê Indietro</button>
                </div>

                <div className="debug-stats">
                    <div className="debug-stat-box"><div className="stat-value seed">{stats.seed}</div><div className="stat-label">Voti Seed</div></div>
                    <div className="debug-stat-box"><div className="stat-value real">{stats.real}</div><div className="stat-label">Voti Reali</div></div>
                    <div className="debug-stat-box"><div className="stat-value total">{stats.total}</div><div className="stat-label">Totale</div></div>
                    <div className="debug-stat-box"><div className="stat-value overall">{overall ? utils.toBase10(overall).toFixed(2) : '-'}</div><div className="stat-label">Overall</div></div>
                </div>

                <h3>üó≥Ô∏è Tutti i Voti</h3>
                <div className="debug-table-wrapper">
                    <table className="debug-table">
                        <thead>
<tr>
    <th>Votante</th>
    <th>Tipo</th>
    {(() => {
        const playerSkills = getSkillsForPlayer(player);
        return [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche].map(skill => (<th key={skill}>{skill.substring(0, 6)}</th>));
    })()}
    <th>Azioni</th>
</tr>
                        </thead>
                        <tbody>
                            {stats.allVotes.map((vote, index) => {
                                const isSeed = vote.voterId.startsWith('seed');
                                const voterName = isSeed ? 'ü§ñ Seed' : (users.find(u => u.id === vote.voterId)?.name || 'Sconosciuto');
                                return (
                                    <tr key={index} className={index % 2 === 0 ? 'even' : 'odd'}>
                                        <td>{voterName}</td>
                                        <td><span className={`vote-type ${isSeed ? 'seed' : 'real'}`}>{isSeed ? 'Seed' : 'Reale'}</span></td>
{(() => {
    const playerSkills = getSkillsForPlayer(player);
    return [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche].map(skill => (<td key={skill}>{vote.ratings[skill] || '-'}</td>));
})()}                                        <td>
                                            <button onClick={() => handleEditVote(vote)} className="admin-btn" style={{marginRight: '5px'}}>‚úèÔ∏è</button>
                                            <button onClick={() => handleDeleteVote(vote.id)} className="admin-btn btn-delete">üóëÔ∏è</button>
                                        </td>
                                    </tr>
                                );
                            })}
                            <tr className="average-row">
                                <td>üìä MEDIA</td>
                                <td></td>
{(() => {
    const playerSkills = getSkillsForPlayer(player);
    return [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche].map(skill => {
        const skillVotes = stats.allVotes.map(v => v.ratings[skill]).filter(v => v !== undefined);
        const avg = skillVotes.length > 0 ? skillVotes.reduce((a, b) => a + b, 0) / skillVotes.length : 0;
        return (<td key={skill}>{avg > 0 ? `${avg.toFixed(2)}` : '-'}</td>);
    });
})()}
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                {editingVote && (
                    <div className="modal-overlay">
                        <div className="modal-content modal-large">
                            <h2>‚úèÔ∏è Modifica Voto</h2>
                            <p>Votante: {editingVote.voterId.startsWith('seed') ? 'ü§ñ Seed' : (users.find(u => u.id === editingVote.voterId)?.name || 'Sconosciuto')}</p>
                            {['tecniche', 'tattiche', 'fisiche'].map(category => (
                                <div key={category} className="vote-edit-category">
                                    <h4 className={`category-${category}`}>{category}</h4>
                                    <div className="vote-edit-grid">
                                        {SKILLS[category].map(skill => (
                                            <div key={skill} className="vote-edit-item">
                                                <label>{skill}</label>
                                                <input 
                                                    type="number" 
                                                    min="1" 
                                                    max="4" 
                                                    step="0.01" 
                                                    value={editVoteValues[skill] || ''} 
                                                    onChange={(e) => setEditVoteValues({...editVoteValues, [skill]: parseFloat(e.target.value) || 0})} 
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                            <div className="modal-actions">
                                <button className="btn btn-secondary" onClick={() => setEditingVote(null)}>Annulla</button>
                                <button className="btn btn-primary" onClick={handleSaveEditedVote}>Salva</button>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    }

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üêõ Debug - Riepilogo Voti</h2>
            </div>

            <div className="debug-global-stats">
                <div className="debug-stat-box"><div className="stat-value seed">{votes.filter(v => v.voterId && v.voterId.startsWith('seed')).length}</div><div className="stat-label">Voti Seed Totali</div></div>
                <div className="debug-stat-box"><div className="stat-value real">{votes.filter(v => v.voterId && !v.voterId.startsWith('seed')).length}</div><div className="stat-label">Voti Reali Totali</div></div>
                <div className="debug-stat-box"><div className="stat-value total">{votes.length}</div><div className="stat-label">Voti Totali</div></div>
            </div>

            <div className="settings-group">
                <h3>üë• Dettaglio per Giocatore</h3>
                <div className="debug-player-list">
                    {players.map(player => {
                        const stats = getVoteStats(player.id);
const averages = utils.calculateAverages(player.id, votes, player);
			const overall = utils.calculateOverall(averages);
                        return (
                            <div key={player.id} className="debug-player-item" onClick={() => setSelectedPlayer(player.id)}>
                                <span style={{fontWeight: '600', minWidth: '150px'}}>{player.name}</span>
                                <span className="debug-badge seed">Seed: {stats.seed}</span>
                                <span className="debug-badge real">Reali: {stats.real}</span>
                                <span className="debug-badge total">Tot: {stats.total}</span>
                                <span style={{color: '#667eea', fontSize: '14px'}}>OVR: {overall ? utils.toBase10(overall).toFixed(2) : '-'}</span>
                            </div>
                        );
                    })}
                </div>
            </div>
        </div>
    );
}
        function App() {
            const getPendingEmail = () => sessionStorage.getItem('pendingEmail');
            const setPendingEmailStorage = (email) => { if (email) { sessionStorage.setItem('pendingEmail', email); } else { sessionStorage.removeItem('pendingEmail'); } };

            const [currentUser, setCurrentUser] = useState(storage.getCurrentUser());
            const [activeTab, setActiveTab] = useState('partite');
            const [selectedPlayer, setSelectedPlayer] = useState(null);
            const [viewingProfile, setViewingProfile] = useState(null);
			const [selectedMatch, setSelectedMatch] = useState(null);
            const [users, setUsers] = useState([]);
            const [votes, setVotes] = useState([]);
            const [showRoleModal, setShowRoleModal] = useState(false);
            const [showClaimModal, setShowClaimModal] = useState(false);
            const [pendingEmail, setPendingEmail] = useState(getPendingEmail());
const [loading, setLoading] = useState(true);
const [showAntonioSelector, setShowAntonioSelector] = useState(false);
const [antonioProfiles, setAntonioProfiles] = useState([]);
			
// Rimuovi i tuoi due useEffect precedenti e usa solo questo:
useEffect(() => {
    // 1. Inizializza il listener di autenticazione Firebase.
    const unsubscribe = firebase.auth().onAuthStateChanged(async (firebaseUser) => {
        if (firebaseUser && firebaseUser.email) {
            // L'utente √® LOGGATO. Ora possiamo leggere il DB.
            
            // 2. AVVIA IL CARICAMENTO DATI (che prima era nel primo useEffect)
            setLoading(true);
            try {
                // A. Leggi TUTTI gli utenti (Necessario per trovare l'utente loggato)
                let loadedUsers = await storage.getUsers();
                if (loadedUsers.length === 0) { loadedUsers = []; }
                
                // B. Trova l'utente loggato all'interno del DB (che ora √® leggibile)
                const email = firebaseUser.email;
                const existingUser = loadedUsers.find(u => u.email === email);
                
                // C. Logica di login/profilo
                if (existingUser) {
                    // Utente Trovato: Completa il Login
                    const userWithAdmin = { ...existingUser, isAdmin: email === ADMIN_EMAIL };
                    
                    // Imposta lo stato utente e lo storage locale
                    setCurrentUser(userWithAdmin);
                    storage.setCurrentUser(userWithAdmin);
                    
                    // D. Carica il resto dei dati (che ora √® permesso)
                    const loadedVotes = await storage.getVotes();
                    
                    // Aggiorna lo stato globale
                    setUsers(loadedUsers);
                    setVotes(loadedVotes);
                    
                    // Gestione modali
                    if (!existingUser.preferredRole) setShowRoleModal(true);
                    
                } else {
                    // Utente NON Trovato: Richiedi registrazione/claim
                    setPendingEmail(email);
                    setShowClaimModal(true);
                }
                
            } catch (error) {
                console.error('Errore caricamento dati DOPO login:', error);
                // Puoi forzare un logout se il database √® inacessibile
                firebase.auth().signOut();
            } finally {
                setLoading(false);
            }
            
        } else {
            // L'utente NON √® loggato (o ha fatto logout)
            setCurrentUser(null);
            storage.setCurrentUser(null);
            setLoading(false); // Assicurati che non rimanga bloccato in caricamento
        }
    });

    // 3. Cleanup: Rimuovi il listener quando il componente viene smontato
    return () => unsubscribe();
    
}, []); // Il dipendente √® vuoto ([]) perch√© il listener deve partire UNA SOLA volta

const handleLogin = (email) => {
    const existingUser = users.find(u => u.email === email);
    if (existingUser) {
        // üÜï CONTROLLO SE √à ANTONIO (ha 2 profili con stessa email)
        const antonioProfiles = users.filter(u => u.email === email);
        if (antonioProfiles.length > 1) {
            // √à Antonio con profili multipli
            setAntonioProfiles(antonioProfiles);
            setShowAntonioSelector(true);
            return;
        }
        
        // Flusso normale
        const userWithAdmin = { ...existingUser, isAdmin: email === ADMIN_EMAIL };
        setCurrentUser(userWithAdmin);
        storage.setCurrentUser(userWithAdmin);
        if (!existingUser.preferredRole) setShowRoleModal(true);
    } else {
        setPendingEmail(email);
        setPendingEmailStorage(email);
        setShowClaimModal(true);
    }
};

const handleClaimProfile = async (playerId) => {
    const isAdmin = pendingEmail === ADMIN_EMAIL;
    const user = users.find(u => u.id === playerId);
    
    // üÜï RICONOSCIMENTO ANTONIO T
    const isAntonio = user.name === 'Antonio T'; // ‚ö†Ô∏è VERIFICA IL NOME ESATTO NEL TUO DB!
    
    if (isAntonio) {
        // Reclama il profilo esistente (movimento)
        const movementProfile = { 
            ...user, 
            email: pendingEmail, 
            claimed: true, 
            isAdmin,
            isGoalkeeper: false,
            name: 'Antonio T - Movimento'
        };
        
        // Crea nuovo profilo portiere
        const goalkeeperProfile = {
            id: `${user.id}_gk`,
            name: 'Antonio T - Portiere',
            email: pendingEmail,
            avatar: user.avatar || null,
            preferredRole: 'Portiere',
            otherRoles: [],
            claimed: true,
            isAdmin,
            isGoalkeeper: true,
            isInitialPlayer: false,
            hasVotedOffline: true
        };
        
        // Salva entrambi
        await storage.updateUser(movementProfile);
        await storage.updateUser(goalkeeperProfile);
        
        const updatedUsers = users.map(u => u.id === playerId ? movementProfile : u).concat([goalkeeperProfile]);
        setUsers(updatedUsers);
        
        // Mostra modal di selezione
        setAntonioProfiles([movementProfile, goalkeeperProfile]);
        setShowAntonioSelector(true);
        setShowClaimModal(false);
        setPendingEmail(null);
        setPendingEmailStorage(null);
        
    } else {
        // Flusso normale per tutti gli altri
        const isGoalkeeper = user.preferredRole === 'Portiere';
        const claimedUser = { ...user, email: pendingEmail, claimed: true, isAdmin, isGoalkeeper };
        await storage.updateUser(claimedUser);
        const updatedUsers = users.map(u => u.id === playerId ? claimedUser : u);
        setUsers(updatedUsers);
        setCurrentUser(claimedUser);
        storage.setCurrentUser(claimedUser);
        setShowClaimModal(false);
        setPendingEmail(null);
        setPendingEmailStorage(null);
        if (!claimedUser.preferredRole) setShowRoleModal(true);
    }
};

            const handleNewPlayer = async (playerName) => {
                const isAdmin = pendingEmail === ADMIN_EMAIL;
const newUser = { id: `player${users.length + 1}`, name: playerName || pendingEmail.split('@')[0], email: pendingEmail, avatar: null, preferredRole: null, otherRoles: [], claimed: true, isAdmin: isAdmin, isInitialPlayer: false, hasVotedOffline: false, isGoalkeeper: false };                await storage.updateUser(newUser);
                setUsers([...users, newUser]);
                setCurrentUser(newUser);
                storage.setCurrentUser(newUser);
                setShowClaimModal(false);
                setPendingEmail(null);
                setPendingEmailStorage(null);
                setShowRoleModal(true);
            };

            const handleLogout = () => { firebase.auth().signOut(); setCurrentUser(null); storage.setCurrentUser(null); };

            const handleVoteSubmit = async (playerId, ratings) => {
                const newVote = { voterId: currentUser.id, voterName: currentUser.name, voterEmail: currentUser.email, playerId, ratings, timestamp: Date.now(), date: new Date().toISOString() };
                await storage.addVote(newVote);
                setVotes([...votes, newVote]);
                setSelectedPlayer(null);
            };

const handleRolesSave = async (preferredRole, otherRoles) => {
    const isGoalkeeper = preferredRole === 'Portiere';
    const updatedCurrentUser = { ...currentUser, preferredRole, otherRoles, isGoalkeeper };
                await storage.updateUser(updatedCurrentUser);
                const updatedUsers = users.map(u => u.id === currentUser.id ? updatedCurrentUser : u);
                setUsers(updatedUsers);
                setCurrentUser(updatedCurrentUser);
                storage.setCurrentUser(updatedCurrentUser);
                setShowRoleModal(false);
            };
// üÜï HANDLER SELEZIONE PROFILO ANTONIO
const handleAntonioProfileSelect = (profile) => {
    setCurrentUser(profile);
    storage.setCurrentUser(profile);
    setShowAntonioSelector(false);
    setAntonioProfiles([]);
};
            if (loading) {
                return (<div className="login-container"><div className="login-card"><h1>‚öΩ Calcetto Rating</h1><p>Caricamento in corso...</p></div></div>);
            }

            if (!currentUser) {
                return (<>{showClaimModal && <ClaimProfileModal users={users} onClaim={handleClaimProfile} onNewPlayer={handleNewPlayer} />}<LoginPage onLogin={handleLogin} /></>);
            }

            return (
                <div className="app-container">
{showRoleModal && <RoleSelectionModal onSave={handleRolesSave} />}
{showAntonioSelector && <ProfileSelectorModal profiles={antonioProfiles} onSelect={handleAntonioProfileSelect} />}
<Header user={currentUser} onLogout={handleLogout} onOpenSettings={() => setActiveTab('impostazioni')} />
                    <div className="nav-tabs">
						<button className={`nav-tab ${activeTab === 'partite' ? 'active' : ''}`} 
        onClick={() => { 
            setActiveTab('partite'); 
            setSelectedPlayer(null); 
            setViewingProfile(null); 
            setSelectedMatch(null); 
        }}>
    üèÜ Partite
</button>
                        <button className={`nav-tab ${activeTab === 'valuta' ? 'active' : ''}`} onClick={() => { setActiveTab('valuta'); setSelectedPlayer(null); setViewingProfile(null); }}>‚öΩ Valuta</button>
                        <button className={`nav-tab ${activeTab === 'profilo' ? 'active' : ''}`} onClick={() => { setActiveTab('profilo'); setSelectedPlayer(null); setViewingProfile(null); }}>üë§ Profilo</button>
                        <button className={`nav-tab ${activeTab === 'classifiche' ? 'active' : ''}`} onClick={() => { setActiveTab('classifiche'); setSelectedPlayer(null); setViewingProfile(null); }}>üìä Classifiche</button>
                        {currentUser.isAdmin && <button className={`nav-tab ${activeTab === 'admin' ? 'active' : ''}`} onClick={() => { setActiveTab('admin'); setSelectedPlayer(null); setViewingProfile(null); }}>üîß Admin</button>}
                        {currentUser.isAdmin && <button className={`nav-tab ${activeTab === 'debug' ? 'active' : ''}`} onClick={() => { setActiveTab('debug'); setSelectedPlayer(null); setViewingProfile(null); }}>üêõ Debug</button>}
                    </div>
                    <div className="content">
                        {viewingProfile ? (
                            <PlayerProfile player={users.find(u => u.id === viewingProfile)} votes={votes} isOwnProfile={viewingProfile === currentUser.id} />
                        ) : selectedPlayer ? (
                            <RatingForm player={users.find(u => u.id === selectedPlayer)} onSubmit={handleVoteSubmit} onCancel={() => setSelectedPlayer(null)} />
                        ) : activeTab === 'partite' ? (
    selectedMatch ? (
        <MatchDetailRouter 
            matchId={selectedMatch}
            currentUser={currentUser}
            onBack={() => setSelectedMatch(null)}
        />
    ) : (
        <MatchesPage 
            currentUser={currentUser} 
            users={users}
            onSelectMatch={setSelectedMatch} 
        />
    )

						) : activeTab === 'valuta' ? (
                            <PlayersListPage users={users} currentUser={currentUser} votes={votes} onSelectPlayer={setSelectedPlayer} />
                        ) : activeTab === 'profilo' ? (
                            <PlayerProfile player={currentUser} votes={votes} isOwnProfile={true} />
                        ) : activeTab === 'classifiche' ? (
    <ClassifichePage users={users} votes={votes} currentUser={currentUser} onViewProfile={setViewingProfile} />
                        ) : activeTab === 'admin' && currentUser.isAdmin ? (
                            <AdminPage users={users} setUsers={setUsers} votes={votes} setVotes={setVotes} />
                        ) : activeTab === 'debug' && currentUser.isAdmin ? (
                            <DebugPage users={users} votes={votes} />
                        ) : (
                            <SettingsPage user={currentUser} onUpdateUser={async (updatedUser) => { await storage.updateUser(updatedUser); const updatedUsers = users.map(u => u.id === updatedUser.id ? updatedUser : u); setUsers(updatedUsers); setCurrentUser(updatedUser); storage.setCurrentUser(updatedUser); }} />
                        )}
                    </div>
                </div>
            );
        }

        try {
            ReactDOM.render(<App />, document.getElementById('root'));
        } catch (error) {
            document.getElementById('root').innerHTML = '<div style="color:white;text-align:center;padding:50px;"><h2>Errore caricamento</h2><p>' + error.message + '</p></div>';
        }
    </script>
<!-- ¬© 2025 Luigi Oliviero | Calcetto Rating App | Tutti i diritti riservati -->
</body>
</html>
