<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcetto Rating App v3</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>	
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyC_81ukybf3QOFFvJcgDWMgbor4Z7k1bgI",
        authDomain: "calcetto-af1e0.firebaseapp.com",
        projectId: "calcetto-af1e0",
        storageBucket: "calcetto-af1e0.firebasestorage.app",
        messagingSenderId: "1035881443344",
        appId: "1:1035881443344:web:2690813dc00bce70d19a95"
      };
      firebase.initializeApp(firebaseConfig);
      const db = firebase.firestore();
    </script>
</head>
<!-- 
================================================================================
  CALCETTO RATING APP
  ¬© 2025 Luigi Oliviero - Tutti i diritti riservati
  
  Questo software √® protetto da copyright e leggi sulla propriet√† intellettuale.
  
  √à SEVERAMENTE VIETATO:
  - Copiare, riprodurre o distribuire questo codice
  - Creare opere derivate senza autorizzazione scritta
  - Utilizzare per scopi commerciali senza licenza
  - Rimuovere o modificare questo avviso di copyright
  
  Uso non autorizzato sar√† perseguito legalmente secondo le leggi italiane 
  ed europee sulla propriet√† intellettuale.
  
  Per licenze commerciali o autorizzazioni: luigi.oliviero@gmail.com
  
  ---
  
  CALCETTO RATING APP
  ¬© 2025 Luigi Oliviero - All Rights Reserved
  
  This software is protected by copyright and intellectual property laws.
  
  STRICTLY PROHIBITED:
  - Copying, reproducing, or distributing this code
  - Creating derivative works without written authorization
  - Commercial use without license
  - Removing or modifying this copyright notice
  
  Unauthorized use will be prosecuted under Italian and European IP laws.
  
  For commercial licensing or permissions: luigi.oliviero@gmail.com
  
  Version: 1.0 | Date: November 2025
================================================================================ -->
<body>
    <div id="root">
        <div className="login-container">
            <div className="login-card">
                <h2>‚öΩ Caricamento...</h2>
                <p>Se rimani bloccato qui, prova a ricaricare la pagina</p>
            </div>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const ADMIN_EMAIL = 'luigi.oliviero@gmail.com';

        const SKILLS = {
            tecniche: ['Tiro', 'Passaggio corto', 'Passaggio lungo', 'Contrasto', 'Controllo'],
            tattiche: ['Visione di gioco', 'Senso della posizione', 'Spirito di sacrificio', 'Letture difensive', 'Costruzione'],
            fisiche: ['Resistenza', 'Scatto', 'Progressione', 'Presenza fisica', 'Cazzimma']
        };

		const shortSKILLS =  {
    	    tecniche: ['TIR', 'PsC', 'PsL', 'CST', 'CTR'],
            tattiche: ['VIS', 'PSZ', 'SAC', 'DIF', 'REG'],
            fisiche: ['RES', 'SCT', 'PRG', 'FIS', 'CZM']
    };
		
		
		const SKILLS_GOALKEEPER = {
    tecniche: ['Parate', 'Uscite', 'Rinvii (piedi)', 'Rilanci (mani)', 'Controllo palla'],
    tattiche: ['Posizionamento', 'Comunicazione', 'Lettura del gioco', 'Gestione area', 'Prima costruzione'],
    fisiche: ['Reattivit√†/Agilit√†', 'Riflessi', 'Elevazione', 'Resistenza', 'Plasticit√† (tuffi)']
};

		const shortSKILLS_GK =  {
    	    tecniche: ['PRT', 'USC', 'RNV', 'RLC', 'CTR'],
            tattiche: ['PSZ', 'CMZ', 'LET', 'GES', 'REG'],
            fisiche: ['AGL', 'RFL', 'ELV', 'RES', 'TUF']
    };

		
const getSkillsForPlayer = (player) => {
    return player.isGoalkeeper ? SKILLS_GOALKEEPER : SKILLS;
};
const getShortSkillsForPlayer = (player) => {
    return player.isGoalkeeper ? shortSKILLS_GK : shortSKILLS;
};

        const ROLES = [
            'Portiere', 'Difensore centrale', 'Difensore laterale sx', 'Difensore laterale dx',
            'Centrocampista difensivo', 'Centrocampista offensivo', 'Mezzala sx', 'Mezzala dx', 'Centravanti'
        ];

        const storage = {
            getUsers: async () => {
                const snapshot = await db.collection('users').get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },
            setUsers: async (users) => {
                const batch = db.batch();
                users.forEach(user => {
                    const ref = db.collection('users').doc(user.id);
                    batch.set(ref, user);
                });
                await batch.commit();
            },
            updateUser: async (user) => {
                await db.collection('users').doc(user.id).set(user);
            },
            getVotes: async () => {
                const snapshot = await db.collection('votes').get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },
            addVote: async (vote) => {
                await db.collection('votes').add(vote);
            },
            setVotes: async (votes) => {
                const batch = db.batch();
                votes.forEach((vote, index) => {
                    const ref = db.collection('votes').doc(`vote_${Date.now()}_${index}`);
                    batch.set(ref, vote);
                });
                await batch.commit();
            },
            getCurrentUser: () => {
                const user = localStorage.getItem('calcetto_current_user');
                return user ? JSON.parse(user) : null;
            },
            setCurrentUser: (user) => {
                if (user) {
                    localStorage.setItem('calcetto_current_user', JSON.stringify(user));
                } else {
                    localStorage.removeItem('calcetto_current_user');
                }
            },
            clearAll: () => {
                localStorage.removeItem('calcetto_current_user');
            },
            getMatches: async () => {
                const snapshot = await db.collection('matches')
                    .orderBy('date', 'desc')
                    .limit(20)
                    .get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },
            getMatch: async (matchId) => {
                const doc = await db.collection('matches').doc(matchId).get();
                return doc.exists ? { id: doc.id, ...doc.data() } : null;
            },
            createMatch: async (matchData) => {
                const ref = await db.collection('matches').add({
                    ...matchData,
                    status: 'OPEN',
                    teams: { gialli: [], verdi: [] },
                    score: null,
                    topScorer: null,
                    topScorerGoals: null,
                    createdAt: Date.now()
                });
                return ref.id;
            },
            // Aggiorna partita (SOLO ADMIN)
            updateMatch: async (matchId, updates) => {
                await db.collection('matches').doc(matchId).update(updates);
            },

            // Cancella partita + tutte le iscrizioni e voti collegati (SOLO ADMIN)
            deleteMatch: async (matchId) => {
                const batch = db.batch();
                
                // Cancella registrations
                const regs = await db.collection('registrations').where('matchId', '==', matchId).get();
                regs.forEach(doc => batch.delete(doc.ref));
                
                // Cancella match_votes
                const votes = await db.collection('match_votes').where('matchId', '==', matchId).get();
                votes.forEach(doc => batch.delete(doc.ref));
                
                // Cancella match
                batch.delete(db.collection('matches').doc(matchId));
                
                await batch.commit();
            },

            // ============================================================================
            // FUNZIONI REGISTRATIONS
            // ============================================================================
            
            // Ottiene tutte le iscrizioni per una partita
            getRegistrations: async (matchId) => {
                const snapshot = await db.collection('registrations')
                    .where('matchId', '==', matchId)
                    .get();
                const registrations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                // Ordina lato client per evitare indice composito
                return registrations.sort((a, b) => a.registeredAt - b.registeredAt);
            },

            // Iscrive un giocatore
            registerPlayer: async (matchId, player) => {
                const regId = `reg_${matchId}_${player.id}`;
                await db.collection('registrations').doc(regId).set({
                    matchId,
                    playerId: player.id,
                    playerName: player.name,
                    isGoalkeeper: player.isGoalkeeper || false,
                    registeredAt: Date.now(),
                    registeredBy: player.id
                });
            },

            // Admin iscrive un altro giocatore
            registerPlayerByAdmin: async (matchId, player, adminId) => {
                const regId = `reg_${matchId}_${player.id}`;
                await db.collection('registrations').doc(regId).set({
                    matchId,
                    playerId: player.id,
                    playerName: player.name,
                    isGoalkeeper: player.isGoalkeeper || false,
                    registeredAt: Date.now(),
                    registeredBy: adminId
                });
            },

            // Disiscrivi giocatore (se stesso o admin)
            unregisterPlayer: async (matchId, playerId) => {
                const regId = `reg_${matchId}_${playerId}`;
                await db.collection('registrations').doc(regId).delete();
            },

            // ============================================================================
            // FUNZIONI MATCH_VOTES
            // ============================================================================

            // Ottiene tutti i voti per una partita
            getMatchVotes: async (matchId) => {
                const snapshot = await db.collection('match_votes')
                    .where('matchId', '==', matchId)
                    .get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },

            // Ottiene il voto di un giocatore specifico
            getMyMatchVote: async (matchId, voterId) => {
                const voteId = `mvote_${matchId}_${voterId}`;
                const doc = await db.collection('match_votes').doc(voteId).get();
                return doc.exists ? { id: doc.id, ...doc.data() } : null;
            },

            // Salva nuovo voto
            saveMatchVote: async (matchId, voterId, voterTeam, votes) => {
                const voteId = `mvote_${matchId}_${voterId}`;
                await db.collection('match_votes').doc(voteId).set({
                    matchId,
                    voterId,
                    voterTeam,
                    votes,
                    submittedAt: Date.now(),
                    lastModifiedAt: Date.now()
                });
            },

            // Modifica voto esistente
            updateMatchVote: async (matchId, voterId, votes) => {
                const voteId = `mvote_${matchId}_${voterId}`;
                await db.collection('match_votes').doc(voteId).update({
                    votes,
                    lastModifiedAt: Date.now()
                });
            },

            // Controlla e aggiorna automaticamente lo status della partita
            checkAndUpdateMatchStatus: async (match) => {
                if (!match) return match;
                
                const now = new Date();
                const matchDate = new Date(match.date);
                const votingDeadline = new Date(match.votingDeadline);
                
                let newStatus = match.status;
                let needsUpdate = false;
                
                // OPEN ‚Üí CLOSED: 30 minuti prima della partita
                if (match.status === 'OPEN') {
                    const closingTime = new Date(matchDate.getTime() - 30 * 60 * 1000); // 30 min prima
                    if (now >= closingTime) {
                        newStatus = 'CLOSED';
                        needsUpdate = true;
                    }
                }
                
                // CLOSED ‚Üí VOTING: 3 ore dopo la partita (solo se ci sono squadre E risultato)
                if (match.status === 'CLOSED') {
                    const votingOpenTime = new Date(matchDate.getTime() + 3 * 60 * 60 * 1000); // 3 ore dopo
                    const hasTeams = match.teams && 
                                    match.teams.gialli && 
                                    match.teams.gialli.length > 0 && 
                                    match.teams.verdi && 
                                    match.teams.verdi.length > 0;
                    const hasScore = match.score && 
                                    match.score.gialli !== null && 
                                    match.score.verdi !== null;
                    
                    if (now >= votingOpenTime && hasTeams && hasScore) {
                        newStatus = 'VOTING';
                        needsUpdate = true;
                    }
                }
                
                // VOTING ‚Üí COMPLETED: 5 giorni dopo apertura voti
                if (match.status === 'VOTING') {
                    if (now >= votingDeadline) {
                        newStatus = 'COMPLETED';
                        needsUpdate = true;
                    }
                }
                
                // Aggiorna se necessario
                if (needsUpdate) {
                    await db.collection('matches').doc(match.id).update({ status: newStatus });
                    return { ...match, status: newStatus };
                }
                
                return match;
            }
        };  // üëà Chiude oggetto storage


        
        const utils = {
            calculateAverages: (playerId, votes, player) => {
                const playerVotes = votes.filter(v => v.playerId === playerId);
                if (playerVotes.length === 0) return null;
                const averages = {};
                const skills = player ? getSkillsForPlayer(player) : SKILLS;
                const allSkills = [...skills.tecniche, ...skills.tattiche, ...skills.fisiche];
                allSkills.forEach(skill => {
                    const values = playerVotes.map(v => v.ratings[skill]).filter(v => v !== undefined);
                    if (values.length > 0) {
                        averages[skill] = values.reduce((a, b) => a + b, 0) / values.length;
                    }
                });
                return averages;
            },
            calculateOverall: (averages) => {
                if (!averages) return null;
                const values = Object.values(averages);
                if (values.length === 0) return null;
                return values.reduce((a, b) => a + b, 0) / values.length;
            },


            calculateCategoryOverall: (averages, category, player) => {
                if (!averages) return null;
                const skills = player ? getSkillsForPlayer(player) : SKILLS;
                const categorySkills = skills[category];
                const values = categorySkills.map(s => averages[s]).filter(v => v !== undefined);
                if (values.length === 0) return null;
                return values.reduce((a, b) => a + b, 0) / values.length;
            },
            countVotes: (playerId, votes) => {
                return votes.filter(v => v.playerId === playerId).length;
            },
            toBase10: (value) => {
                return (value / 4) * 10;
            },
            getInitials: (name) => {
                return name.substring(0, 2).toUpperCase();
            },

            // ============================================================================
            // HELPER FUNCTIONS PER PARTITE - Aggiungi dentro l'oggetto utils
            // ============================================================================

            // Formatta data partita (es: "Gioved√¨ 29 Novembre")
            formatMatchDate: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['Domenica', 'Luned√¨', 'Marted√¨', 'Mercoled√¨', 'Gioved√¨', 'Venerd√¨', 'Sabato'];
                const mesi = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 
                              'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'];
                return `${giorni[date.getDay()]} ${date.getDate()} ${mesi[date.getMonth()]}`;
            },

            // Formatta data completa (es: "Gioved√¨ 29 Novembre 2024")
            formatMatchDateFull: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['Domenica', 'Luned√¨', 'Marted√¨', 'Mercoled√¨', 'Gioved√¨', 'Venerd√¨', 'Sabato'];
                const mesi = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 
                              'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'];
                return `${giorni[date.getDay()]} ${date.getDate()} ${mesi[date.getMonth()]} ${date.getFullYear()}`;
            },

            // Formatta ora (es: "21:20")
            formatTime: (dateString) => {
                const date = new Date(dateString);
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${hours}:${minutes}`;
            },

            // Formatta deadline display (es: "luned√¨ 24 novembre")
            formatDeadlineDisplay: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['domenica', 'luned√¨', 'marted√¨', 'mercoled√¨', 'gioved√¨', 'venerd√¨', 'sabato'];
                const mesi = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 
                              'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
                return `${giorni[date.getDay()]} ${date.getDate()} ${mesi[date.getMonth()]}`;
            },

            // Formatta deadline breve (es: "Lun 24, 20:00")
            formatDeadline: (dateString) => {
                const date = new Date(dateString);
                const giorni = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
                const day = date.getDate();
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${giorni[date.getDay()]} ${day}, ${hours}:${minutes}`;
            },

            // Renderizza icone guanti portieri (0, 1 o 2)
            renderGoalkeeperIcons: (count) => {
                if (count === 0) return '';
                if (count === 1) return 'üß§';
                return 'üß§üß§';
            },

            // Trova il nome di un giocatore dal suo ID
            getPlayerNameById: (playerId, users) => {
                // Prova prima con users se disponibile
                if (users && users.length > 0) {
                    const player = users.find(u => u.id === playerId);
                    if (player) return player.name;
                }
                // Fallback: mostra solo ID
                return playerId;
            }
        };

        function LoginPage({ onLogin }) {
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            const handleGoogleLogin = () => {
                setLoading(true);
                setError('');
                const provider = new firebase.auth.GoogleAuthProvider();
                firebase.auth().signInWithPopup(provider)
                    .then((result) => { onLogin(result.user.email); })
                    .catch((err) => {
                        console.error(err);
                        setError('Errore: ' + err.message);
                        setLoading(false);
                    });
            };

            return (
                <div className="login-container">
                    <div className="login-card">
                        <h1>‚öΩ Calcetto Rating</h1>
                        <p>Valuta i tuoi compagni di squadra</p>
                        {error && <p className="error-message">{error}</p>}
                        <button className="google-btn" onClick={handleGoogleLogin} disabled={loading}>
                            <span>üîê</span>
                            {loading ? 'Accesso in corso...' : 'Accedi con Google'}
                        </button>
                        <p className="login-hint">Al primo accesso potrai associare il tuo profilo</p>
                    </div>
                </div>
            );
        }

        function ClaimProfileModal({ users, onClaim, onNewPlayer }) {
            const [selectedPlayer, setSelectedPlayer] = useState('');
            const [newPlayerName, setNewPlayerName] = useState('');
            const availablePlayers = users.filter(u => !u.claimed && !u.id.startsWith('seed'));

            return (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>üëã Benvenuto!</h2>
                        <p>Chi sei tra questi giocatori?</p>
                        <div className="form-group">
                            <label>Seleziona il tuo nome:</label>
                            <select value={selectedPlayer} onChange={(e) => setSelectedPlayer(e.target.value)}>
                                <option value="">-- Seleziona il tuo profilo --</option>
                                {availablePlayers.map(player => (
                                    <option key={player.id} value={player.id}>{player.name}</option>
                                ))}
                            </select>
                        </div>
                        <button className="btn btn-primary full-width" onClick={() => selectedPlayer && onClaim(selectedPlayer)} disabled={!selectedPlayer}>
                            ‚úì Sono io!
                        </button>
                        <div className="modal-divider">
                            <p className="modal-hint">Non trovi il tuo nome?</p>
                            <input type="text" placeholder="Scrivi il tuo nome e cognome" value={newPlayerName} onChange={(e) => setNewPlayerName(e.target.value)} />
                            <button className="btn btn-secondary full-width" onClick={() => onNewPlayer(newPlayerName)} disabled={!newPlayerName.trim()}>
                                + Sono un nuovo giocatore
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        function RoleSelectionModal({ onSave }) {
            const [preferredRole, setPreferredRole] = useState('');
            const [otherRoles, setOtherRoles] = useState([]);

            const handleOtherRoleToggle = (role) => {
                if (otherRoles.includes(role)) {
                    setOtherRoles(otherRoles.filter(r => r !== role));
                } else {
                    setOtherRoles([...otherRoles, role]);
                }
            };

const handleSubmit = () => {
    if (!preferredRole) { alert('Seleziona il tuo ruolo preferito'); return; }
    // I portieri non devono obbligatoriamente scegliere altri ruoli
    const isGoalkeeper = preferredRole === 'Portiere';
    if (!isGoalkeeper && otherRoles.length < 2) { 
        alert('Seleziona almeno 2 altri ruoli'); 
        return; 
    }
    onSave(preferredRole, otherRoles);
};

            const availableOtherRoles = ROLES.filter(r => r !== preferredRole);

            return (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>‚öΩ Benvenuto!</h2>
                        <p>Prima di iniziare, raccontaci qualcosa di te</p>
                        <div className="form-group">
                            <label>Qual √® il tuo ruolo preferito? *</label>
                            <select value={preferredRole} onChange={(e) => setPreferredRole(e.target.value)}>
                                <option value="">-- Seleziona --</option>
                                {ROLES.map(role => (<option key={role} value={role}>{role}</option>))}
                            </select>
                        </div>
                        <div className="form-group">
<label>In quali altri ruoli ti adatti? {preferredRole === 'Portiere' ? '(opzionale)' : '(min. 2) *'}</label>
                            <div className="checkbox-group">
                                {availableOtherRoles.map(role => (
                                    <div key={role} className="checkbox-item">
                                        <input type="checkbox" id={`role-${role}`} checked={otherRoles.includes(role)} onChange={() => handleOtherRoleToggle(role)} />
                                        <label htmlFor={`role-${role}`}>{role}</label>
                                    </div>
                                ))}
                            </div>
                        </div>
						<button className={`btn btn-primary full-width ${(!preferredRole || (preferredRole !== 'Portiere' && otherRoles.length < 2)) ? 'btn-disabled' : ''}`} onClick={handleSubmit} disabled={!preferredRole || (preferredRole !== 'Portiere' && otherRoles.length < 2)}>
    Conferma {preferredRole !== 'Portiere' && otherRoles.length < 2 && preferredRole ? `(${otherRoles.length}/2 ruoli)` : ''}
						</button>
                    </div>
                </div>
            );
        }
function RoleEditModal({ user, onClose, onSuccess }) {
    const [preferredRole, setPreferredRole] = useState(user.preferredRole || '');
    const [otherRoles, setOtherRoles] = useState(user.otherRoles || []);

    const handleOtherRoleToggle = (role) => {
        if (otherRoles.includes(role)) {
            setOtherRoles(otherRoles.filter(r => r !== role));
        } else {
            setOtherRoles([...otherRoles, role]);
        }
    };

    const handleSubmit = async () => {
        if (!preferredRole) { 
            alert('Seleziona il tuo ruolo preferito'); 
            return; 
        }
        if (otherRoles.length < 2) { 
            alert('Seleziona almeno 2 altri ruoli'); 
            return; 
        }
        
        const updatedUser = { 
            ...user, 
            preferredRole, 
            otherRoles 
        };
        
        await storage.updateUser(updatedUser);
        storage.setCurrentUser(updatedUser);
        onSuccess();
    };

    const availableOtherRoles = ROLES.filter(r => r !== preferredRole);

    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <h2>‚úèÔ∏è Modifica Ruoli</h2>
                <p>Aggiorna le tue preferenze di ruolo</p>
                
                <div className="form-group">
                    <label>Qual √® il tuo ruolo preferito? *</label>
                    <select value={preferredRole} onChange={(e) => setPreferredRole(e.target.value)}>
                        <option value="">-- Seleziona --</option>
                        {ROLES.map(role => (
                            <option key={role} value={role}>{role}</option>
                        ))}
                    </select>
                </div>
                
                <div className="form-group">
                    <label>In quali altri ruoli ti adatti? (min. 2) *</label>
                    <div className="checkbox-group">
                        {availableOtherRoles.map(role => (
                            <div key={role} className="checkbox-item">
                                <input 
                                    type="checkbox" 
                                    id={`edit-role-${role}`} 
                                    checked={otherRoles.includes(role)} 
                                    onChange={() => handleOtherRoleToggle(role)} 
                                />
                                <label htmlFor={`edit-role-${role}`}>{role}</label>
                            </div>
                        ))}
                    </div>
                </div>
                
                <div className="modal-actions">
                    <button className="btn btn-secondary" onClick={onClose}>
                        Annulla
                    </button>
                    <button 
                        className={`btn btn-primary ${(!preferredRole || otherRoles.length < 2) ? 'btn-disabled' : ''}`} 
                        onClick={handleSubmit} 
                        disabled={!preferredRole || otherRoles.length < 2}
                    >
                        Salva Modifiche {otherRoles.length < 2 && preferredRole ? `(${otherRoles.length}/2 ruoli)` : ''}
                    </button>
                </div>
            </div>
        </div>
    );
}

		function ProfileSelectorModal({ profiles, onSelect }) {
    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <h2>üëã Ciao Antonio!</h2>
                <p>Con quale profilo vuoi entrare?</p>
                <div style={{display: 'flex', flexDirection: 'column', gap: '15px', marginTop: '25px'}}>
                    {profiles.map(profile => (
                        <button 
                            key={profile.id}
                            className="btn btn-primary full-width" 
                            onClick={() => onSelect(profile)}
                            style={{fontSize: '1.1rem', padding: '18px'}}
                        >
                            {profile.isGoalkeeper ? 'üß§' : 'üë§'} {profile.name}
                        </button>
                    ))}
                </div>
            </div>
        </div>
    );
}
		
        function Header({ user, onLogout }) {
            return (
                <div className="header">
                    <div className="header-left">
                        <h1>‚öΩ Calcetto del <span style={{color: 'var(--volt)'}}>gioved√¨</span></h1>
                        <p>Dedicata a quelli che il week-end inizia con la partitella</p>
                    </div>
                    <div className="user-info">
                        <div className="avatar">
                            {user.avatar ? <img src={user.avatar} alt={user.name} /> : utils.getInitials(user.name)}
                        </div>
                        <div>
                            <div className="user-name">{user.name}</div>
                            <div className="user-email">{user.email}</div>
                        </div>
                        <button className="logout-btn" onClick={onLogout}>Esci</button>
                    </div>
                </div>
            );
        }


// ============================================================================
// COMPONENTI PARTITE
// ============================================================================

function MatchCard({ match, currentUser, users, onClick }) {
    const [registrations, setRegistrations] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        loadRegistrations();
    }, [match.id]);

    const loadRegistrations = async () => {
        try {
            const regs = await storage.getRegistrations(match.id);
            setRegistrations(regs);
        } catch (error) {
            console.error('Errore caricamento iscrizioni:', error);
        }
        setLoading(false);
    };

    const getStatusBadge = () => {
        if (match.status === 'OPEN' || match.status === 'CLOSED') {
            return { text: 'üìù APERTA', class: 'open' };
        }
        if (match.status === 'VOTING') {
            return { text: '‚≠ê DA VOTARE', class: 'voting' };
        }
        return { text: '‚úÖ FINITA', class: 'completed' };
    };

    const countGoalkeepers = () => {
        return registrations.filter(r => r.isGoalkeeper).length;
    };

    const status = getStatusBadge();
    const gkCount = countGoalkeepers();

    if (loading) {
        return (
            <div className="match-card">
                <div className="match-card-center">
                    <h3>Caricamento...</h3>
                </div>
            </div>
        );
    }

    return (
        <div className={`match-card ${status.class}`} onClick={onClick}>
            <div className="match-card-left">
                <span className={`match-status ${status.class}`}>{status.text}</span>
            </div>
            <div className="match-card-center">
                <h3>{utils.formatMatchDate(match.date)}</h3>
            </div>
            <div className="match-card-right">
                {(match.status === 'OPEN' || match.status === 'CLOSED') && (
                    <>
                        <div className="match-info">
                            üë• {registrations.length}/{match.maxPlayers} {utils.renderGoalkeeperIcons(gkCount)}
                        </div>
                        <div className="match-info" style={{fontSize: '0.75rem'}}>
                            Chiude: {utils.formatDeadline(match.registrationDeadlineForced)}
                        </div>
                    </>
                )}
                {match.status === 'VOTING' && match.score && (
                    <>
                        <div className="match-info">
                            Gialli {match.score.gialli}-{match.score.verdi} Verdi
                        </div>
                        <div className="match-info" style={{fontSize: '0.75rem'}}>
                            üó≥Ô∏è Vota entro domenica
                        </div>
                    </>
                )}
                {match.status === 'COMPLETED' && match.score && (
                    <>
                        <div className="match-info">
                            Gialli {match.score.gialli}-{match.score.verdi} Verdi
                        </div>
                        <div className="match-info" style={{fontSize: '0.75rem'}}>
                            üèÜ {utils.getPlayerNameById(match.topScorer, users)}
                        </div>
                    </>
                )}
            </div>
        </div>
    );
}

function MatchesPage({ currentUser, users, onSelectMatch }) {
    const [matches, setMatches] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        loadMatches();
    }, []);

const loadMatches = async () => {
    setLoading(true);
    try {
        const data = await storage.getMatches();
        
        // Controlla e aggiorna status automaticamente
        const updatedMatches = await Promise.all(
            data.map(match => storage.checkAndUpdateMatchStatus(match))
        );
        
        setMatches(updatedMatches);
    } catch (error) {
        console.error('Errore caricamento partite:', error);
    }
    setLoading(false);
};

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üèÜ Le Tue Partite</h2>
            </div>

            {loading ? (
                <div className="no-votes">
                    <h3>Caricamento partite...</h3>
                </div>
            ) : matches.length === 0 ? (
                <div className="no-votes">
                    <h3>Nessuna partita in programma</h3>
                    <p>L'admin creer√† presto la prossima partita!</p>
                </div>
            ) : (
                <div className="matches-list">
                    {matches.map(match => (
                        <MatchCard
                            key={match.id}
                            match={match}
                            currentUser={currentUser}
                            users={users}
                            onClick={() => onSelectMatch(match.id)}
                        />
                    ))}
                </div>
            )}
        </div>
    );
}


// ============================================================================
// VISTA ISCRIZIONI PARTITA
// ============================================================================

function MatchRegistrationView({ match, currentUser, users, onBack, onUpdate }) {
	const [registrations, setRegistrations] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [actionLoading, setActionLoading] = React.useState(false);
	const [showAddPlayerModal, setShowAddPlayerModal] = React.useState(false);
    const [selectedPlayerId, setSelectedPlayerId] = React.useState('');
    const [isGoalkeeper, setIsGoalkeeper] = React.useState(false);

    React.useEffect(() => {
        loadRegistrations();
    }, [match.id]);

    const loadRegistrations = async () => {
        setLoading(true);
        try {
            const regs = await storage.getRegistrations(match.id);
            setRegistrations(regs);
        } catch (error) {
            console.error('Errore caricamento iscrizioni:', error);
        }
        setLoading(false);
    };

    const isRegistered = registrations.some(r => r.playerId === currentUser.id);
    const isClosed = match.status === 'CLOSED';

    const handleRegister = async () => {
        setActionLoading(true);
        try {
            await storage.registerPlayer(match.id, currentUser);
            await loadRegistrations();
            if (onUpdate) onUpdate();
        } catch (error) {
            console.error('Errore iscrizione:', error);
            alert('Errore durante l\'iscrizione. Riprova.');
        }
        setActionLoading(false);
    };

	
	
    const handleUnregister = async (playerId, playerName) => {
        const isCurrentUser = playerId === currentUser.id;
        const message = isCurrentUser 
            ? 'Vuoi disiscriverti dalla partita?' 
            : `Rimuovere ${playerName} dalla partita?`;
        
        if (!confirm(message)) return;

        setActionLoading(true);
        try {
            await storage.unregisterPlayer(match.id, playerId);
            await loadRegistrations();
            if (onUpdate) onUpdate();
        } catch (error) {
            console.error('Errore disiscrizione:', error);
            alert('Errore durante la disiscrizione. Riprova.');
        }
        setActionLoading(false);
    };

	const handleAddPlayer = async () => {
        if (!selectedPlayerId) {
            alert('Seleziona un giocatore!');
            return;
        }

        setActionLoading(true);
        try {
            const player = users.find(u => u.id === selectedPlayerId);
            const playerToAdd = {
                ...player,
                isGoalkeeper: isGoalkeeper
            };
            
            await storage.registerPlayerByAdmin(match.id, playerToAdd, currentUser.id);
            await loadRegistrations();
            if (onUpdate) onUpdate();
            
            // Reset e chiudi modale
            setSelectedPlayerId('');
            setIsGoalkeeper(false);
            setShowAddPlayerModal(false);
        } catch (error) {
            console.error('Errore aggiunta giocatore:', error);
            alert('Errore durante l\'aggiunta. Riprova.');
        }
        setActionLoading(false);
    };

    const getAvailablePlayers = () => {
        const registeredIds = registrations.map(r => r.playerId);
        return users.filter(u => !registeredIds.includes(u.id));
    };

    const countGoalkeepers = () => {
        return registrations.filter(r => r.isGoalkeeper).length;
    };

    if (loading) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>Caricamento...</h2>
                </div>
            </div>
        );
    }

    return (
        <>
            <div className="section-container">
                <div className="detail-card">
                    <div className="detail-header">
                        <span className={`match-status ${isClosed ? 'completed' : 'open'}`}>
                            {isClosed ? 'üîí ISCRIZIONI CHIUSE' : 'üìù ISCRIZIONI APERTE'}
                        </span>

                        <div className="header-info-grid">
                            <div className="header-main">
                                <div className="detail-date">{utils.formatMatchDateFull(match.date)}</div>
                                <div className="detail-time">‚è∞ Ore {utils.formatTime(match.date)}</div>
                                <div className="detail-location">üìç {match.location}</div>
                            </div>
                            <div className="header-aside">
                                <div className="recap-box">
                                    <div className="recap-row">
                                        {utils.renderGoalkeeperIcons(countGoalkeepers())}
                                        <span><strong>{registrations.length}</strong>/{match.maxPlayers}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="detail-content">
                        <div className="players-list">
                            <h3>üë• Chi Gioca ({registrations.length})</h3>
                            {registrations.length === 0 ? (
                                <div className="no-votes">
                                    <p>Nessun iscritto ancora. Sii il primo!</p>
                                </div>
                            ) : (
                                registrations.map(reg => (
                                    <div key={reg.id} className={`player-item ${reg.isGoalkeeper ? 'gk' : ''}`}>
                                        <div className="avatar">{utils.getInitials(reg.playerName)}</div>
                                        <div className="player-info">
                                            <div className="player-name">
                                                {reg.playerName}
                                                {reg.playerId === currentUser.id && ' (Tu)'}
                                            </div>
                                            <div className="player-role">
                                                {reg.isGoalkeeper ? 'üß§ Portiere' : 'Movimento'}
                                            </div>
                                        </div>

                                        {/* X ROSSA: mostra solo se sono io O se sono admin */}
                                        {(reg.playerId === currentUser.id || currentUser.isAdmin) && !isClosed && (
                                            <div 
                                                className="unsubscribe-btn" 
                                                onClick={() => handleUnregister(reg.playerId, reg.playerName)}
                                            >
                                                ‚úï
                                            </div>
                                        )}
                                    </div>
                                ))
                            )}
                        </div>

                        {/* üÜï ADMIN: AGGIUNGI GIOCATORE */}
                        {currentUser.isAdmin && !isClosed && (
                            <div className="admin-add-player">
                                <button 
                                    className="btn-add-player" 
                                    onClick={() => setShowAddPlayerModal(true)}
                                >
                                    + AGGIUNGI GIOCATORE
                                </button>
                            </div>
                        )}

                        {!isClosed && (
                            <div className="deadline-msg">
                                Iscriviti entro le ore 20 del {utils.formatDeadlineDisplay(match.registrationDeadlineDisplay)}<br/>
                                per avere la possibilit√† di cambiare campo se necessario
                            </div>
                        )}

                        {isClosed && (
                            <div className="deadline-msg closed">
                                Le iscrizioni sono chiuse.<br/>
                                L'admin sta preparando le squadre!
                            </div>
                        )}

                        <div className="btn-group">
                            <button className="btn btn-secondary" onClick={onBack}>
                                ‚Üê INDIETRO
                            </button>
                            {!isClosed && (
                                isRegistered ? (
                                    <button className="btn btn-registered" disabled>
                                        ‚úì SONO GI√Ä ISCRITTO
                                    </button>
                                ) : (
                                    <button 
                                        className="btn btn-primary" 
                                        onClick={handleRegister} 
                                        disabled={actionLoading}
                                    >
                                        {actionLoading ? 'Attendere...' : '‚úì ISCRIVITI'}
                                    </button>
                                )
                            )}
                        </div>
                    </div>
                </div>
            </div>

            {/* üÜï MODALE AGGIUNGI GIOCATORE */}
            {showAddPlayerModal && (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>üë• Aggiungi Giocatore</h2>
                        
                        <div className="form-group">
                            <label>Seleziona Giocatore *</label>
                            <select 
                                value={selectedPlayerId}
                                onChange={(e) => setSelectedPlayerId(e.target.value)}
                            >
                                <option value="">-- Seleziona --</option>
                                {getAvailablePlayers().map(player => (
                                    <option key={player.id} value={player.id}>
                                        {player.name}
                                    </option>
                                ))}
                            </select>
                        </div>

                        <div className="form-group">
                            <div className="checkbox-item">
                                <input 
                                    type="checkbox" 
                                    id="admin-gk"
                                    checked={isGoalkeeper}
                                    onChange={(e) => setIsGoalkeeper(e.target.checked)}
                                />
                                <label htmlFor="admin-gk">üß§ √à un portiere</label>
                            </div>
                        </div>

                        <div className="modal-actions">
                            <button 
                                className="btn btn-secondary" 
                                onClick={() => {
                                    setShowAddPlayerModal(false);
                                    setSelectedPlayerId('');
                                    setIsGoalkeeper(false);
                                }}
                            >
                                Annulla
                            </button>
                            <button 
                                className="btn btn-primary" 
                                onClick={handleAddPlayer}
                                disabled={!selectedPlayerId || actionLoading}
                            >
                                {actionLoading ? 'Attendere...' : '‚úì Aggiungi'}
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </>
    );
}

// ============================================================================
// VISTA VOTAZIONI PARTITA
// ============================================================================

function MatchVotingView({ match, currentUser, onBack }) {
    const [votes, setVotes] = React.useState({});
    const [hasVoted, setHasVoted] = React.useState(false);
    const [loading, setLoading] = React.useState(true);
    const [submitting, setSubmitting] = React.useState(false);

    React.useEffect(() => {
        loadVotingData();
    }, [match.id]);

    const loadVotingData = async () => {
        setLoading(true);
        try {
            // Controlla se ho gi√† votato
            const myVote = await storage.getMyMatchVote(match.id, currentUser.id);
            if (myVote) {
                setVotes(myVote.votes);
                setHasVoted(true);
            }
        } catch (error) {
            console.error('Errore caricamento voti:', error);
        }
        setLoading(false);
    };

    // Determina il team dell'utente
    const getUserTeam = () => {
        if (match.teams.gialli.includes(currentUser.id)) return 'gialli';
        if (match.teams.verdi.includes(currentUser.id)) return 'verdi';
        return null;
    };

    // Ottieni lista giocatori da votare (tutti tranne me stesso)
    const getPlayersToVote = () => {
        const allPlayers = [...match.teams.gialli, ...match.teams.verdi];
        return allPlayers.filter(playerId => playerId !== currentUser.id);
    };

    // Ottieni team di un giocatore
    const getPlayerTeam = (playerId) => {
        if (match.teams.gialli.includes(playerId)) return 'gialli';
        return 'verdi';
    };

    const handleVoteChange = (playerId, value) => {
        setVotes(prev => ({
            ...prev,
            [playerId]: parseFloat(value)
        }));
    };

    const isComplete = () => {
        const playersToVote = getPlayersToVote();
        return playersToVote.every(playerId => votes[playerId] !== undefined);
    };

    const handleSubmit = async () => {
        if (!isComplete()) {
            alert('Devi votare tutti i giocatori prima di inviare!');
            return;
        }

        setSubmitting(true);
        try {
            const userTeam = getUserTeam();
            await storage.saveMatchVote(match.id, currentUser.id, userTeam, votes);
            setHasVoted(true);
            alert('‚úÖ Voti inviati con successo!');
        } catch (error) {
            console.error('Errore invio voti:', error);
            alert('Errore durante l\'invio dei voti. Riprova.');
        }
        setSubmitting(false);
    };

    const handleModify = () => {
        setHasVoted(false);
    };

    const isDeadlinePassed = () => {
        return new Date() > new Date(match.votingDeadline);
    };

    const canModify = hasVoted && !isDeadlinePassed();
    const isLocked = hasVoted && isDeadlinePassed();

    if (loading) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>Caricamento...</h2>
                </div>
            </div>
        );
    }

    const playersToVote = getPlayersToVote();
    const gialliToVote = playersToVote.filter(p => getPlayerTeam(p) === 'gialli');
    const verdiToVote = playersToVote.filter(p => getPlayerTeam(p) === 'verdi');

    return (
        <div className="section-container">
            <div className="voting-card">
                <div className="voting-header">
                    <span className="match-status voting">‚≠ê DA VOTARE</span>

                    <div className="voting-score">
                        <span className="team-name gialli">GIALLI</span>
                        <span className="score">{match.score.gialli} - {match.score.verdi}</span>
                        <span className="team-name verdi">VERDI</span>
                    </div>

                    <div className="voting-info">
                        <div className="voting-date">{utils.formatMatchDateFull(match.date)}</div>
                        <div className="voting-note">üí° Vota tutti i giocatori eccetto te stesso</div>
                    </div>
                </div>

                <div className="voting-content">
                    {!hasVoted && (
                        <>
                            {/* SQUADRA GIALLI */}
                            <div className="team-voting-section">
                                <h3 className="team-section-title gialli">üü° GIALLI</h3>
                                {gialliToVote.map(playerId => (
                                    <div key={playerId} className="vote-row">
                                        <div className="vote-row-name">
                                            {utils.getPlayerNameById(playerId, [])}
                                        </div>
                                        <input
                                            type="range"
                                            min="1"
                                            max="10"
                                            step="0.5"
                                            value={votes[playerId] || 5}
                                            onChange={(e) => handleVoteChange(playerId, e.target.value)}
                                            className="vote-slider"
                                        />
                                        <div className="vote-value">
                                            {votes[playerId] ? votes[playerId].toFixed(1) : '5.0'}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            {/* SQUADRA VERDI */}
                            <div className="team-voting-section">
                                <h3 className="team-section-title verdi">üü¢ VERDI</h3>
                                {verdiToVote.map(playerId => (
                                    <div key={playerId} className="vote-row">
                                        <div className="vote-row-name">
                                            {utils.getPlayerNameById(playerId, [])}
                                        </div>
                                        <input
                                            type="range"
                                            min="1"
                                            max="10"
                                            step="0.5"
                                            value={votes[playerId] || 5}
                                            onChange={(e) => handleVoteChange(playerId, e.target.value)}
                                            className="vote-slider"
                                        />
                                        <div className="vote-value">
                                            {votes[playerId] ? votes[playerId].toFixed(1) : '5.0'}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </>
                    )}

                    {hasVoted && (
                        <>
                            {/* VOTI GI√Ä INVIATI */}
                            <div className="team-voting-section">
                                <h3 className="team-section-title gialli">üü° GIALLI</h3>
                                {gialliToVote.map(playerId => (
                                    <div key={playerId} className="vote-row readonly">
                                        <div className="vote-row-name">
                                            {utils.getPlayerNameById(playerId, [])}
                                        </div>
                                        <div className="vote-readonly-value">
                                            {votes[playerId] ? votes[playerId].toFixed(1) : '-'}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="team-voting-section">
                                <h3 className="team-section-title verdi">üü¢ VERDI</h3>
                                {verdiToVote.map(playerId => (
                                    <div key={playerId} className="vote-row readonly">
                                        <div className="vote-row-name">
                                            {utils.getPlayerNameById(playerId, [])}
                                        </div>
                                        <div className="vote-readonly-value">
                                            {votes[playerId] ? votes[playerId].toFixed(1) : '-'}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            {canModify && (
                                <div className="deadline-msg">
                                    Puoi modificare fino a {utils.formatDeadlineDisplay(match.votingDeadline)}, 24:00
                                </div>
                            )}

                            {isLocked && (
                                <div className="deadline-msg closed">
                                    Le votazioni si sono chiuse {utils.formatDeadlineDisplay(match.votingDeadline)}, 24:00
                                </div>
                            )}
                        </>
                    )}

                    <div className="btn-group">
                        <button className="btn btn-secondary" onClick={onBack}>
                            ‚Üê INDIETRO
                        </button>
                        {!hasVoted && (
                            <button 
                                className="btn btn-primary" 
                                onClick={handleSubmit}
                                disabled={!isComplete() || submitting}
                            >
                                {submitting ? 'Invio...' : '‚úì INVIA VOTI'}
                            </button>
                        )}
                        {canModify && (
                            <button className="btn btn-primary" onClick={handleModify}>
                                ‚úèÔ∏è MODIFICA VOTI
                            </button>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
}

		

// ============================================================================
// ROUTER DETTAGLIO PARTITA
// ============================================================================

function MatchDetailRouter({ matchId, currentUser, onBack }) {
    const [match, setMatch] = React.useState(null);
    const [loading, setLoading] = React.useState(true);
    const [users, setUsers] = React.useState([]);  // üÜï AGGIUNGI

    React.useEffect(() => {
        loadMatch();
        loadUsers();  // üÜï AGGIUNGI
    }, [matchId]);

    const loadUsers = async () => {  // üÜï AGGIUNGI FUNZIONE
        try {
            const allUsers = await storage.getUsers();
            setUsers(allUsers);
        } catch (error) {
            console.error('Errore caricamento utenti:', error);
        }
    };

const loadMatch = async () => {
    setLoading(true);
    try {
        let data = await storage.getMatch(matchId);
        
        // Controlla e aggiorna status automaticamente
        data = await storage.checkAndUpdateMatchStatus(data);
        
        setMatch(data);
    } catch (error) {
        console.error('Errore caricamento partita:', error);
    }
    setLoading(false);
};

    if (loading) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>Caricamento...</h2>
                </div>
            </div>
        );
    }

    if (!match) {
        return (
            <div className="section-container">
                <div className="no-votes">
                    <h3>Partita non trovata</h3>
                    <button className="btn btn-secondary" onClick={onBack}>
                        ‚Üê Torna alle Partite
                    </button>
                </div>
            </div>
        );
    }

    // Router: quale vista mostrare in base allo status?
    if (match.status === 'OPEN' || match.status === 'CLOSED') {
return (
    <MatchRegistrationView 
        match={match} 
        currentUser={currentUser}
        users={users}
        onBack={onBack}
        onUpdate={loadMatch}
    />
);
    }

if (match.status === 'VOTING') {
    return (
        <MatchVotingView 
            match={match} 
            currentUser={currentUser} 
            onBack={onBack}
        />
    );
}

    // COMPLETED
    return (
        <div className="section-container">
            <div className="no-votes">
                <h3>‚úÖ Partita conclusa</h3>
                <p>Vista risultati in arrivo...</p>
                <button className="btn btn-secondary" onClick={onBack}>
                    ‚Üê Torna alle Partite
                </button>
            </div>
        </div>
    );
}
		
		
        function PlayersListPage({ users, currentUser, votes, onSelectPlayer }) {
    const hasVoted = (playerId) => {
        return votes.some(v => v.voterId === currentUser.id && v.playerId === playerId);
    };
    
    const playersToVote = users.filter(u => {
        if (u.id === currentUser.id || u.id.startsWith('seed')) return false;
        if (hasVoted(u.id)) return false;
        if (currentUser.hasVotedOffline && u.isInitialPlayer) return false;
        return true;
    });

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>Seleziona un giocatore da valutare</h2>
            </div>
            
            {playersToVote.length === 0 ? (
                <div className="no-votes">
                    <h3>üéâ Ottimo lavoro, hai valutato tutti!</h3>
                    {currentUser.hasVotedOffline && <p>Hai gi√† votato tutti. Potrai votare i nuovi iscritti.</p>}
                </div>
            ) : (
                <div className="players-grid">
                    {playersToVote.map(player => (
                        <div key={player.id} className="player-card" onClick={() => onSelectPlayer(player.id)}>
                            <div className="avatar">{player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}</div>
<h3>{player.name} {player.isGoalkeeper && 'üß§'}</h3>
<div className="status">
    {player.isGoalkeeper && <span className="goalkeeper-badge">üß§ PORTIERE</span>}
    {!player.isInitialPlayer && <span className="new-badge">‚≠ê NUOVO</span>}
                                <div>Clicca per valutare</div>
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}

function RatingForm({ player, onSubmit, onCancel }) {
    const [ratings, setRatings] = useState({});
    const playerSkills = getSkillsForPlayer(player);

    const isComplete = () => {
        const allSkills = [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche];
                return allSkills.every(skill => ratings[skill]);
            };

            const handleSubmit = () => {
                if (isComplete()) { onSubmit(player.id, ratings); } 
                else { alert('Completa tutte le valutazioni prima di inviare'); }
            };

            return (
                <div className="rating-form">
                    <div className="form-header">
                        <div className="avatar">{player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}</div>
<h2>Valuta {player.name} {player.isGoalkeeper && 'üß§'}</h2>
                        <p>Scala: 1=Scarso | 2=Sufficiente | 3=Buono | 4=Ottimo</p>
                    </div>
{Object.entries(playerSkills).map(([category, skills]) => (             
	<div key={category} className="category-section">
                            <div className={`category-title category-${category}`}>{category.charAt(0).toUpperCase() + category.slice(1)}</div>
                            {skills.map(skill => (
                                <div key={skill} className="skill-item">
                                    <div className="skill-name">{skill}</div>
                                    <div className="rating-buttons">
                                        {[1, 2, 3, 4].map(value => (
                                            <button key={value} className={`rating-btn ${ratings[skill] === value ? 'selected' : ''}`} onClick={() => setRatings(prev => ({...prev, [skill]: value}))}>
                                                {value}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    ))}
                    <div className="form-actions">
                        <button className="btn btn-secondary" onClick={onCancel}>Annulla</button>
                        <button className="btn btn-primary" onClick={handleSubmit} disabled={!isComplete()}>‚úì Invia Valutazione</button>
                    </div>
                </div>
            );
        }

        function RadarChart({ data, labels, shortLabels, category }) {
            const canvasRef = useRef(null);

            useEffect(() => {
                if (!canvasRef.current || !data) return;
                const ctx = canvasRef.current.getContext('2d');
                if (canvasRef.current.chart) { canvasRef.current.chart.destroy(); }

                const colors = {
                    tecniche: 'rgba(102, 126, 234, 0.6)',
                    tattiche: 'rgba(72, 187, 120, 0.6)',
                    fisiche: 'rgba(245, 101, 101, 0.6)'
                };
                const borderColors = {
                    tecniche: 'rgb(102, 126, 234)',
                    tattiche: 'rgb(72, 187, 120)',
                    fisiche: 'rgb(245, 101, 101)'
                };

                canvasRef.current.chart = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: shortLabels,
                        datasets: [{
                            label: category.charAt(0).toUpperCase() + category.slice(1),
                            data: labels.map(label => utils.toBase10(data[label])),
                            backgroundColor: colors[category],
                            borderColor: borderColors[category],
                            borderWidth: 2,
                            pointBackgroundColor: borderColors[category],
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: borderColors[category]
                        }]
                    },
                    options: {
                        scales: { 
                            r: { 
                                beginAtZero: true, 
                                max: 10, 
                                min: 0, 
                                ticks: { 
                                    stepSize: 2,
                                    color: 'rgba(255, 255, 255, 0.5)',
                                    backdropColor: 'transparent'
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)',
                                    circular: true
                                },
                                angleLines: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                pointLabels: {
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    font: {
                                        size: 11
                                    }
                                }
                            } 
                        },
                        plugins: { legend: { display: false } }
                    }
                });

                return () => { if (canvasRef.current?.chart) { canvasRef.current.chart.destroy(); } };
            }, [data, labels, category]);

            return <canvas ref={canvasRef} className="chart-canvas"></canvas>;
        }

function PlayerProfile({ player, votes, isOwnProfile }) {
    const playerVotes = votes.filter(v => v.playerId === player.id);
    const voteCount = playerVotes.length;
    const hasEnoughVotes = voteCount >= 5;
const averages = utils.calculateAverages(player.id, votes, player);
    const overall = utils.calculateOverall(averages);
    const [flippedCard, setFlippedCard] = useState(null);
	   const playerSkills = getSkillsForPlayer(player);

    const handleCardClick = (category) => {
        if (window.innerWidth <= 768) {
            setFlippedCard(flippedCard === category ? null : category);
        }
    };

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>Profilo Giocatore</h2>
            </div>
            
            <div className="profile-header">
                <div className="avatar profile-avatar">
                    {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                </div>
                
                <div className="profile-header-info">
<h2>{player.name} {player.isGoalkeeper && 'üß§'}</h2>
                    <div className="votes-count">Sulla base di {voteCount} valutazioni ricevute</div>
                </div>
                
                {(player.preferredRole || (player.otherRoles && player.otherRoles.length > 0)) && (
                    <div className="role-info">
                        {player.preferredRole && (
                            <div className="role-item">
                                <div className="role-label">Ruolo preferito</div>
                                <div className="role-value">{player.preferredRole}</div>
                            </div>
                        )}
                        {player.otherRoles && player.otherRoles.length > 0 && (
                            <div className="role-item">
                                <div className="role-label">Mi adatto anche a</div>
                                <div className="role-badges">
                                    {player.otherRoles.map(role => (<span key={role} className="role-badge">{role}</span>))}
                                </div>
                            </div>
                        )}
                    </div>
                )}
            </div>

            {hasEnoughVotes && overall && (
                <div className="overall-container">
                    <div className="overall-main">{utils.toBase10(overall).toFixed(2)}</div>
                    <div className="overall-label">Overall Rating</div>
                </div>
            )}

            {hasEnoughVotes && averages ? (
                <div className="charts-container">
    {Object.entries(getSkillsForPlayer(player)).map(([category, skills]) => {
        
        const shortSkills = getShortSkillsForPlayer(player)[category];  
        const catOverall = utils.calculateCategoryOverall(averages, category, player);

        return (
            <div 
                key={category} 
                className={`chart-box ${flippedCard === category ? 'flipped' : ''}`}
                onClick={() => handleCardClick(category)}
            >
                <div className="chart-box-inner">
                    
                    {/* FRONT (Radar) */}
                    <div className="chart-box-front">
                        <h3 className={`category-${category}`}>
                            {category.charAt(0).toUpperCase() + category.slice(1)}
                        </h3>

                        {catOverall && (
                            <div className="category-overall">
                                {utils.toBase10(catOverall).toFixed(2)}
                            </div>
                        )}

                        <RadarChart 
    data={averages}
    labels={skills}         // skill estese ‚Üí per i valori
    shortLabels={shortSkills} // abbreviazioni ‚Üí per visualizzare
    category={category}
/>
                    </div>

                    {/* BACK (Lista dettagliata con label estese) */}
                    <div className="chart-box-back">
                        <h4 className={`category-${category}`}>
                            {category.charAt(0).toUpperCase() + category.slice(1)}
                        </h4>
                        <div className="chart-detail-list">
                            {skills.map(skill => (
                                <div key={skill} className="chart-detail-item">
                                    <span>{skill}</span> {/* <-- estesa */}
                                    <span className={`category-${category}`}>
                                        {averages[skill]
                                            ? utils.toBase10(averages[skill]).toFixed(2)
                                            : '-'}
                                    </span>
                                </div>
                            ))}
                        </div>
                    </div>

                </div>
            </div>
        );
    })}
</div>
			)
 : (
                <div className="no-votes">
                    <h3>üìä Grafici non disponibili</h3>
                    <p>{isOwnProfile ? "Chiedi ai tuoi compagni di valutarti!" : "Questo giocatore ha bisogno di pi√π valutazioni"}</p>
                    <p>Servono almeno 5 valutazioni (attualmente: {voteCount})</p>
                </div>
            )}
        </div>
    );
}

function ClassifichePage({ users, votes, currentUser, onViewProfile }) {
    // üÜï Conta i voti fatti dall'utente corrente
    const userVotesCount = votes.filter(v => v.voterId === currentUser.id).length;
    const canViewLeaderboard = userVotesCount >= 5;
    
    const playersWithStats = users
        .filter(u => !u.id.startsWith('seed'))
        .map(player => {
            const averages = utils.calculateAverages(player.id, votes, player);
            const overall = utils.calculateOverall(averages);
            const voteCount = utils.countVotes(player.id, votes);
            return { ...player, overall, voteCount };
        })
        .filter(p => p.overall !== null)
        .sort((a, b) => b.overall - a.overall);

    // üÜï Mostra messaggio se non ha votato abbastanza
    if (!canViewLeaderboard) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>üìä Classifica Generale</h2>
                </div>
                
                <div className="no-votes">
                    <h3>üîí Classifica Bloccata</h3>
                    <p>Per visualizzare la classifica devi completare almeno 5 valutazioni</p>
                    <p style={{marginTop: '15px', fontSize: '1.2rem', color: 'var(--volt)'}}>
                        Hai completato: <strong>{userVotesCount}/5</strong> valutazioni
                    </p>
                    <p style={{marginTop: '10px', opacity: '0.8'}}>
                        Vai alla sezione "Valuta" per votare altri giocatori!
                    </p>
                </div>
            </div>
        );
    }

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üìä Classifica Generale</h2>
            </div>
            
            {playersWithStats.length === 0 ? (
                <div className="no-votes">
                    <h3>Nessuna classifica disponibile</h3>
                    <p>I giocatori devono ricevere almeno 5 valutazioni per apparire</p>
                </div>
            ) : (
                <div className="leaderboard-container">
                    {playersWithStats.map((player, index) => (
                        <div 
                            key={player.id}
                            className={`leaderboard-item ${index < 3 ? `rank-${index + 1}` : ''}`}
                            onClick={() => onViewProfile(player.id)}
                        >
                            <div className="rank-number">
                                {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}
                            </div>
                            <div className="avatar">
                                {player.avatar ? <img src={player.avatar} alt={player.name} /> : utils.getInitials(player.name)}
                            </div>
                            <div style={{flex: 1}}>
                                <div style={{fontWeight: '600', fontSize: '18px'}}>{player.name} {player.isGoalkeeper && 'üß§'}</div>
                                <div style={{fontSize: '13px', opacity: 0.8}}>{player.voteCount} valutazioni</div>
                            </div>
                            <div style={{fontWeight: '800', fontSize: '28px'}}>{utils.toBase10(player.overall).toFixed(2)}</div>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}
function SettingsPage({ user, onUpdateUser }) {
    const [showSuccess, setShowSuccess] = useState(false);
    const [showRoleEdit, setShowRoleEdit] = useState(false);

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onloadend = async () => {
                const updatedUser = { ...user, avatar: reader.result };
                await onUpdateUser(updatedUser);
                setShowSuccess(true);
                setTimeout(() => setShowSuccess(false), 3000);
            };
            reader.readAsDataURL(file);
        }
    };

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>‚öôÔ∏è Impostazioni</h2>
            </div>
            
            <div className="settings-group">
                <h3>Foto Profilo</h3>
                <div className="settings-info">
                    <div className="settings-avatar">
                        {user.avatar ? <img src={user.avatar} alt={user.name} /> : utils.getInitials(user.name)}
                    </div>
                    <div className="file-input-wrapper">
                        <input type="file" id="avatar-upload" accept="image/*" onChange={handleFileChange} />
                        <label htmlFor="avatar-upload" className="file-input-label">üì∑ Carica Foto</label>
                    </div>
                </div>
            </div>

            <div className="settings-group">
                <h3>Informazioni Account</h3>
                <div className="settings-info-box">
                    <div style={{marginBottom: '15px'}}><strong>Nome:</strong> {user.name}</div>
                    <div><strong>Email:</strong> {user.email}</div>
                </div>
            </div>

            <div className="settings-group">
                <h3>Ruoli</h3>
                <div className="settings-info-box">
                    <div style={{marginBottom: '15px'}}>
                        <strong>Ruolo preferito:</strong> {user.preferredRole || 'Non impostato'}
                    </div>
                    <div style={{marginBottom: '15px'}}>
                        <strong>Altri ruoli:</strong>
                        <div style={{marginTop: '8px'}}>
                            {user.otherRoles && user.otherRoles.length > 0 ? (
                                <div className="role-badges">
                                    {user.otherRoles.map(role => (
                                        <span key={role} className="role-badge">{role}</span>
                                    ))}
                                </div>
                            ) : (
                                <span style={{color: '#718096'}}>Nessuno</span>
                            )}
                        </div>
                    </div>
                    <button className="btn btn-secondary" onClick={() => setShowRoleEdit(true)} style={{marginTop: '10px'}}>
                        ‚úèÔ∏è Modifica Ruoli
                    </button>
                </div>
            </div>

            {showSuccess && <div className="success-message">‚úì Impostazioni aggiornate!</div>}

            {showRoleEdit && (
                <RoleEditModal 
                    user={user}
                    onClose={() => setShowRoleEdit(false)}
                    onSuccess={async () => { 
                        const updatedUser = await storage.getUsers().then(users => users.find(u => u.id === user.id));
                        await onUpdateUser(updatedUser);
                        setShowRoleEdit(false); 
                        setShowSuccess(true); 
                        setTimeout(() => setShowSuccess(false), 3000); 
                    }}
                />
            )}
        </div>
    );
}



function AdminPage({ users, setUsers, votes, setVotes }) {
    const [editingPlayer, setEditingPlayer] = useState(null);
    const [editName, setEditName] = useState('');
    const [showSuccess, setShowSuccess] = useState(false);
    const [successMessage, setSuccessMessage] = useState('');
    const [editingVotes, setEditingVotes] = useState(null);
    const [voteValues, setVoteValues] = useState({});


// === STATI PER GESTIONE PARTITE ===
    const [showCreateMatch, setShowCreateMatch] = useState(false);
    const [newMatchDate, setNewMatchDate] = useState('');
    const [newMatchTime, setNewMatchTime] = useState('21:20');
    const [newMatchLocation, setNewMatchLocation] = useState('Campo SuperSantos, Portici');
    const [newMatchMaxPlayers, setNewMatchMaxPlayers] = useState(18);
    const [adminMatches, setAdminMatches] = useState([]);
    const [adminRegistrations, setAdminRegistrations] = useState({});
    
    // üÜï STATI PER ASSEGNAZIONE SQUADRE E RISULTATO
    const [showTeamAssignment, setShowTeamAssignment] = useState(false);
    const [selectedMatchForTeams, setSelectedMatchForTeams] = useState(null);
    const [teamGialli, setTeamGialli] = useState([]);
    const [teamVerdi, setTeamVerdi] = useState([]);
    const [showScoreModal, setShowScoreModal] = useState(false);
    const [selectedMatchForScore, setSelectedMatchForScore] = useState(null);
    const [scoreGialli, setScoreGialli] = useState('');
    const [scoreVerdi, setScoreVerdi] = useState('');
    const [topScorer, setTopScorer] = useState('');
    const [topScorerGoals, setTopScorerGoals] = useState('');

    // Carica partite all'avvio
    useEffect(() => {
        loadAdminMatches();
    }, []);

const loadAdminMatches = async () => {
    try {
        const matches = await storage.getMatches();
        
        // Controlla e aggiorna status automaticamente
        const updatedMatches = await Promise.all(
            matches.map(match => storage.checkAndUpdateMatchStatus(match))
        );
        
        setAdminMatches(updatedMatches);
        
        // Carica iscrizioni per ogni partita
        const regsMap = {};
        for (const match of updatedMatches) {
            const regs = await storage.getRegistrations(match.id);
            regsMap[match.id] = regs;
        }
        setAdminRegistrations(regsMap);
    } catch (error) {
        console.error('Errore caricamento partite admin:', error);
    }
};

    const handleCreateMatch = async () => {
        if (!newMatchDate || !newMatchTime || !newMatchLocation) {
            alert('Compila tutti i campi obbligatori');
            return;
        }

        try {
            // Costruisci data completa
            const matchDateTime = new Date(`${newMatchDate}T${newMatchTime}:00`);
            
            // Deadline display: 4 giorni prima alle 20:00
            const regDeadlineDisplay = new Date(matchDateTime);
            regDeadlineDisplay.setDate(regDeadlineDisplay.getDate() - 4);
            regDeadlineDisplay.setHours(20, 0, 0, 0);
            
            // Deadline forzata: 50 minuti prima della partita
            const regDeadlineForced = new Date(matchDateTime);
            regDeadlineForced.setMinutes(regDeadlineForced.getMinutes() - 50);
            
            // Deadline voti: 3 giorni dopo alle 24:00
            const votingDeadline = new Date(matchDateTime);
            votingDeadline.setDate(votingDeadline.getDate() + 3);
            votingDeadline.setHours(24, 0, 0, 0);

            await storage.createMatch({
                date: matchDateTime.toISOString(),
                location: newMatchLocation,
                maxPlayers: parseInt(newMatchMaxPlayers),
                registrationDeadlineDisplay: regDeadlineDisplay.toISOString(),
                registrationDeadlineForced: regDeadlineForced.toISOString(),
                votingDeadline: votingDeadline.toISOString()
            });

            // Reset form
            setNewMatchDate('');
            setNewMatchTime('21:20');
            setNewMatchLocation('Campo SuperSantos, Portici');
            setNewMatchMaxPlayers(18);
            setShowCreateMatch(false);
            
            showSuccessMsg('Partita creata!');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore creazione partita:', error);
            alert('Errore durante la creazione della partita');
        }
    };

    const handleCloseRegistrations = async (matchId) => {
        if (!confirm('Chiudere le iscrizioni per questa partita?')) return;
        
        try {
            await storage.updateMatch(matchId, { status: 'CLOSED' });
            showSuccessMsg('Iscrizioni chiuse!');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore chiusura iscrizioni:', error);
            alert('Errore durante la chiusura');
        }
    };

    const handleDeleteMatch = async (matchId) => {
        if (!confirm('‚ö†Ô∏è ATTENZIONE: Eliminare questa partita e tutte le iscrizioni?')) return;
        if (!confirm('Conferma: sei sicuro di voler eliminare tutto?')) return;
        
        try {
            await storage.deleteMatch(matchId);
            showSuccessMsg('Partita eliminata!');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore eliminazione partita:', error);
            alert('Errore durante l\'eliminazione');
        }
    };

    // üÜï GESTIONE ASSEGNAZIONE SQUADRE
    const handleOpenTeamAssignment = async (matchId) => {
        const match = adminMatches.find(m => m.id === matchId);
        const regs = adminRegistrations[matchId] || [];
        
        if (regs.length < 2) {
            alert('Servono almeno 2 giocatori iscritti per assegnare le squadre');
            return;
        }
        
        setSelectedMatchForTeams(match);
        
        // Se gi√† ci sono squadre, caricale
        if (match.teams && match.teams.gialli && match.teams.gialli.length > 0) {
            setTeamGialli(match.teams.gialli);
            setTeamVerdi(match.teams.verdi);
        } else {
            // Altrimenti genera squadre bilanciate
            generateBalancedTeams(regs);
        }
        
        setShowTeamAssignment(true);
    };

    const generateBalancedTeams = (registrations) => {
        // Separa portieri e giocatori
        const goalkeepers = registrations.filter(r => r.isGoalkeeper);
        const players = registrations.filter(r => !r.isGoalkeeper);
        
        // Mescola array
        const shuffledPlayers = [...players].sort(() => Math.random() - 0.5);
        
        // Dividi giocatori a met√†
        const halfPlayers = Math.ceil(shuffledPlayers.length / 2);
        let gialli = shuffledPlayers.slice(0, halfPlayers);
        let verdi = shuffledPlayers.slice(halfPlayers);
        
        // Distribuisci portieri
        if (goalkeepers.length === 1) {
            gialli.push(goalkeepers[0]);
        } else if (goalkeepers.length >= 2) {
            gialli.push(goalkeepers[0]);
            verdi.push(goalkeepers[1]);
        }
        
        setTeamGialli(gialli);
        setTeamVerdi(verdi);
    };

    const movePlayerToTeam = (player, fromTeam, toTeam) => {
        if (fromTeam === 'gialli') {
            setTeamGialli(teamGialli.filter(p => p.playerId !== player.playerId));
            setTeamVerdi([...teamVerdi, player]);
        } else {
            setTeamVerdi(teamVerdi.filter(p => p.playerId !== player.playerId));
            setTeamGialli([...teamGialli, player]);
        }
    };

    const handleSaveTeams = async () => {
        if (teamGialli.length === 0 || teamVerdi.length === 0) {
            alert('Entrambe le squadre devono avere almeno un giocatore');
            return;
        }
        
        try {
            await storage.updateMatch(selectedMatchForTeams.id, {
                teams: {
                    gialli: teamGialli,
                    verdi: teamVerdi
                }
            });
            
            showSuccessMsg('Squadre assegnate!');
            setShowTeamAssignment(false);
            setSelectedMatchForTeams(null);
            setTeamGialli([]);
            setTeamVerdi([]);
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore salvataggio squadre:', error);
            alert('Errore durante il salvataggio');
        }
    };

    // üÜï GESTIONE RISULTATO
    const handleOpenScoreModal = (matchId) => {
        const match = adminMatches.find(m => m.id === matchId);
        
        if (!match.teams || !match.teams.gialli || match.teams.gialli.length === 0) {
            alert('Devi prima assegnare le squadre!');
            return;
        }
        
        setSelectedMatchForScore(match);
        
        // Se gi√† c'√® un risultato, caricalo
        if (match.score) {
            setScoreGialli(match.score.gialli.toString());
            setScoreVerdi(match.score.verdi.toString());
        }
        if (match.topScorer) {
            setTopScorer(match.topScorer);
            setTopScorerGoals(match.topScorerGoals?.toString() || '');
        }
        
        setShowScoreModal(true);
    };

    const handleSaveScore = async () => {
        if (!scoreGialli || !scoreVerdi) {
            alert('Inserisci entrambi i punteggi');
            return;
        }
        
        const gialliScore = parseInt(scoreGialli);
        const verdiScore = parseInt(scoreVerdi);
        
        if (isNaN(gialliScore) || isNaN(verdiScore) || gialliScore < 0 || verdiScore < 0) {
            alert('Inserisci punteggi validi');
            return;
        }
        
        try {
            const updates = {
                score: {
                    gialli: gialliScore,
                    verdi: verdiScore
                }
            };
            
            // Aggiungi capocannoniere se presente
            if (topScorer && topScorerGoals) {
                updates.topScorer = topScorer;
                updates.topScorerGoals = parseInt(topScorerGoals);
            }
            
            await storage.updateMatch(selectedMatchForScore.id, updates);
            
            showSuccessMsg('Risultato salvato!');
            setShowScoreModal(false);
            setSelectedMatchForScore(null);
            setScoreGialli('');
            setScoreVerdi('');
            setTopScorer('');
            setTopScorerGoals('');
            await loadAdminMatches();
        } catch (error) {
            console.error('Errore salvataggio risultato:', error);
            alert('Errore durante il salvataggio');
        }
    };




	
    const showSuccessMsg = (msg) => {
        setSuccessMessage(msg);
        setShowSuccess(true);
        setTimeout(() => setShowSuccess(false), 3000);
    };

    const handleEditName = (player) => {
        setEditingPlayer(player.id);
        setEditName(player.name);
    };

    const handleSaveName = async (playerId) => {
        if (!editName.trim()) return;
        const updatedUser = users.find(u => u.id === playerId);
        updatedUser.name = editName.trim();
        await storage.updateUser(updatedUser);
        const updatedUsers = users.map(u => u.id === playerId ? updatedUser : u);
        setUsers(updatedUsers);
        setEditingPlayer(null);
        setEditName('');
        showSuccessMsg('Nome aggiornato!');
    };

    const handleDeletePlayer = async (playerId) => {
        if (!confirm('Eliminare questo giocatore e tutte le sue valutazioni?')) return;
        const updatedUsers = users.filter(u => u.id !== playerId);
        setUsers(updatedUsers);
        await storage.setUsers(updatedUsers);
        showSuccessMsg('Giocatore eliminato!');
    };

    const handleEditVotes = (player) => {
const averages = utils.calculateAverages(player.id, votes, player);
		if (averages) {
            const values = {};
            Object.keys(averages).forEach(k => { values[k] = averages[k].toFixed(2); });
            setVoteValues(values);
        } else {
            const emptyValues = {};
            [...SKILLS.tecniche, ...SKILLS.tattiche, ...SKILLS.fisiche].forEach(skill => { emptyValues[skill] = ''; });
            setVoteValues(emptyValues);
        }
        setEditingVotes(player);
    };

    const handleSaveVotes = async () => {
        for (let i = 0; i < 8; i++) {
            const seedVote = { 
                voterId: `seed_admin_${i}_${Date.now()}`, 
                playerId: editingVotes.id, 
                ratings: {}, 
                timestamp: Date.now() 
            };
            [...SKILLS.tecniche, ...SKILLS.tattiche, ...SKILLS.fisiche].forEach(skill => {
                const value = parseFloat(voteValues[skill]);
                if (!isNaN(value)) seedVote.ratings[skill] = Math.round(value);
            });
            await storage.addVote(seedVote);
        }
        setEditingVotes(null);
        setVoteValues({});
        showSuccessMsg('Valutazioni aggiornate!');
        setTimeout(() => window.location.reload(), 1000);
    };

    const handleAddPlayer = async () => {
        const newName = prompt('Nome del nuovo giocatore:');
        if (!newName || !newName.trim()) return;
        const newPlayer = { id: `player${Date.now()}`, name: newName.trim(), avatar: null, preferredRole: null, otherRoles: [], email: null, claimed: false, isAdmin: false };
        await storage.updateUser(newPlayer);
        setUsers([...users, newPlayer]);
        showSuccessMsg('Giocatore aggiunto!');
    };

    const handleFullReset = () => {
        if (!confirm('‚ö†Ô∏è ATTENZIONE: Eliminare TUTTI i dati?')) return;
        if (!confirm('Conferma: vuoi davvero cancellare tutto?')) return;
        storage.clearAll();
        window.location.reload();
    };

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üîß Pannello Amministratore</h2>
            </div>

            {showSuccess && <div className="success-message">‚úì {successMessage}</div>}

            <div className="settings-group">
                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px'}}>
                    <h3>üë• Gestione Giocatori ({users.filter(u => !u.id.startsWith('seed')).length})</h3>
                    <button className="btn btn-primary" onClick={handleAddPlayer}>+ Aggiungi</button>
                </div>
                
                <div className="admin-player-list">
                    {users.filter(u => !u.id.startsWith('seed')).map((player, index) => {
                        const voteCount = utils.countVotes(player.id, votes);
                        const averages = utils.calculateAverages(player.id, votes);
                        const overall = utils.calculateOverall(averages);
                        
                        return (
                            <div key={player.id} className="admin-player-item">
                                <span style={{color: '#a0aec0', width: '25px'}}>{index + 1}.</span>
                                
                                {editingPlayer === player.id ? (
                                    <div style={{display: 'flex', gap: '10px', flex: 1}}>
                                        <input type="text" value={editName} onChange={(e) => setEditName(e.target.value)} className="admin-input" autoFocus />
                                        <button onClick={() => handleSaveName(player.id)} className="admin-btn btn-save">‚úì</button>
                                        <button onClick={() => setEditingPlayer(null)} className="admin-btn btn-cancel">‚úï</button>
                                    </div>
                                ) : (
                                    <>
                                        <span style={{fontWeight: '600', minWidth: '140px'}}>{player.name}</span>
                                        <span style={{color: '#718096', fontSize: '13px', flex: 1}}>{player.claimed ? `‚úì ${player.email}` : '‚óã Non reclamato'}</span>
                                        <span style={{color: '#667eea', fontSize: '13px'}}>OVR: {overall ? utils.toBase10(overall).toFixed(2) : '-'} ({voteCount} voti)</span>
                                        <div style={{display: 'flex', gap: '6px'}}>
                                            <button onClick={() => handleEditName(player)} className="admin-btn">‚úèÔ∏è</button>
                                            <button onClick={() => handleEditVotes(player)} className="admin-btn btn-chart">üìä</button>
                                            <button onClick={() => handleDeletePlayer(player.id)} className="admin-btn btn-delete">üóëÔ∏è</button>
                                        </div>
                                    </>
                                )}
                            </div>
                        );
                    })}
                </div>
            </div>
            
            <div className="settings-group">
                <h3>üíæ Backup Database</h3>
                <p>Esporta o importa tutti i dati (utenti e voti) per fare backup o ripristinare</p>
                <div style={{display: 'flex', gap: '15px', marginTop: '15px'}}>
                    <button className="btn btn-primary" onClick={() => {
                        const data = { users, votes, timestamp: Date.now(), date: new Date().toISOString() };
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `calcetto_backup_${new Date().toISOString().split('T')[0]}.json`;
                        a.click();
                        showSuccessMsg('Backup esportato!');
                    }}>üì• Esporta Backup</button>
                    <button className="btn btn-secondary" onClick={() => {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.json';
                        input.onchange = async (e) => {
                            try {
                                const file = e.target.files[0];
                                const text = await file.text();
                                const data = JSON.parse(text);
                                if (!confirm('‚ö†Ô∏è ATTENZIONE: Questo sovrascriver√† tutti i dati attuali. Continuare?')) return;
                                if (data.users) await storage.setUsers(data.users);
                                if (data.votes) await storage.setVotes(data.votes);
                                showSuccessMsg('Backup importato!');
                                setTimeout(() => window.location.reload(), 1000);
                            } catch (err) {
                                alert('Errore durante l\'importazione: ' + err.message);
                            }
                        };
                        input.click();
                    }}>üì§ Importa Backup</button>
                </div>
            </div>

<div className="settings-group">
                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px'}}>
                    <h3>üèÜ Gestione Partite</h3>
                    <button className="btn btn-primary" onClick={() => setShowCreateMatch(!showCreateMatch)}>
                        {showCreateMatch ? '‚úï Annulla' : '+ Crea Partita'}
                    </button>
                </div>

                {showCreateMatch && (
                    <div className="admin-create-match">
                        <h4>Crea Nuova Partita</h4>
                        
                        <div className="form-group">
                            <label>Data Partita *</label>
                            <input 
                                type="date" 
                                value={newMatchDate}
                                onChange={(e) => setNewMatchDate(e.target.value)}
                            />
                        </div>

                        <div className="form-group">
                            <label>Orario *</label>
                            <input 
                                type="time" 
                                value={newMatchTime}
                                onChange={(e) => setNewMatchTime(e.target.value)}
                            />
                        </div>

                        <div className="form-group">
                            <label>Location *</label>
                            <input 
                                type="text" 
                                value={newMatchLocation}
                                onChange={(e) => setNewMatchLocation(e.target.value)}
                                placeholder="Es: Campo SuperSantos, Portici"
                            />
                        </div>

                        <div className="form-group">
                            <label>Max Giocatori</label>
                            <input 
                                type="number" 
                                min="10"
                                max="30"
                                value={newMatchMaxPlayers}
                                onChange={(e) => setNewMatchMaxPlayers(e.target.value)}
                            />
                        </div>

                        <button 
                            className="btn btn-primary" 
                            onClick={handleCreateMatch}
                            disabled={!newMatchDate || !newMatchTime || !newMatchLocation}
                        >
                            ‚úì Crea Partita
                        </button>
                    </div>
                )}

                <div className="admin-matches-list">
                    {adminMatches.map(match => {
                        const regs = adminRegistrations[match.id] || [];
                        return (
                            <div key={match.id} className="admin-match-item">
                                <div className="admin-match-header">
                                    <span className={`match-status ${match.status.toLowerCase()}`}>
                                        {match.status === 'OPEN' && 'üìù APERTA'}
                                        {match.status === 'CLOSED' && 'üîí CHIUSA'}
                                        {match.status === 'VOTING' && '‚≠ê VOTAZIONI'}
                                        {match.status === 'COMPLETED' && '‚úÖ FINITA'}
                                    </span>
                                    <span className="admin-match-date">{utils.formatMatchDate(match.date)}</span>
                                </div>
                                
                                <div className="admin-match-info">
                                    <span>üìç {match.location}</span>
                                    <span>üë• {regs.length}/{match.maxPlayers}</span>
                                </div>

                                <div className="admin-match-actions">
                                    {match.status === 'OPEN' && (
                                        <button 
                                            className="admin-action-btn close"
                                            onClick={() => handleCloseRegistrations(match.id)}
                                        >
                                            üîí Chiudi Iscrizioni
                                        </button>
                                    )}
                                    {match.status === 'CLOSED' && (
                                        <>
                                            <button 
                                                className="admin-action-btn assign"
                                                onClick={() => handleOpenTeamAssignment(match.id)}
                                            >
                                                üë• Assegna Squadre
                                            </button>
                                            <button 
                                                className="admin-action-btn score"
                                                onClick={() => handleOpenScoreModal(match.id)}
                                            >
                                                ‚öΩ Inserisci Risultato
                                            </button>
                                        </>
                                    )}
                                    <button 
                                        className="admin-action-btn delete"
                                        onClick={() => handleDeleteMatch(match.id)}
                                    >
                                        üóëÔ∏è Elimina
                                    </button>
                                </div>
                            </div>
                        );
                    })}
                </div>
            </div>




			
            <div className="settings-group admin-danger-zone">
                <h3>‚ö†Ô∏è Zona Pericolosa</h3>
                <p>Azioni irreversibili!</p>
                <button className="btn btn-danger" onClick={handleFullReset}>üóëÔ∏è Reset Completo</button>
            </div>

            {editingVotes && (
                <div className="modal-overlay">
                    <div className="modal-content modal-large">
                        <h2>üìä Modifica: {editingVotes.name}</h2>
                        <p>Inserisci valori 1-4. Verranno creati 8 voti seed.</p>
                        {['tecniche', 'tattiche', 'fisiche'].map(category => (
                            <div key={category} className="vote-edit-category">
                                <h4 className={`category-${category}`}>{category}</h4>
                                <div className="vote-edit-grid">
                                    {SKILLS[category].map(skill => (
                                        <div key={skill} className="vote-edit-item">
                                            <label>{skill}</label>
                                            <input type="number" min="1" max="4" step="0.01" value={voteValues[skill] || ''} onChange={(e) => setVoteValues({...voteValues, [skill]: e.target.value})} />
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                        <div className="modal-actions">
                            <button className="btn btn-secondary" onClick={() => setEditingVotes(null)}>Annulla</button>
                            <button className="btn btn-primary" onClick={handleSaveVotes}>Salva</button>
                        </div>
                    </div>
                </div>
            )}

            {/* üÜï MODALE ASSEGNAZIONE SQUADRE */}
            {showTeamAssignment && selectedMatchForTeams && (
                <div className="modal-overlay">
                    <div className="modal-content modal-large">
                        <h2>üë• Assegna Squadre - {utils.formatMatchDate(selectedMatchForTeams.date)}</h2>
                        <p>Trascina i giocatori tra le squadre o usa il bilanciamento automatico</p>

                        <div style={{display: 'flex', gap: '20px', marginTop: '20px'}}>
                            {/* SQUADRA GIALLI */}
                            <div style={{flex: 1, background: 'rgba(255, 215, 0, 0.1)', padding: '15px', borderRadius: '8px', border: '2px solid #FFD700'}}>
                                <h3 style={{color: '#FFD700', marginBottom: '15px'}}>
                                    üü° GIALLI ({teamGialli.length})
                                </h3>
                                <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
                                    {teamGialli.map(player => (
                                        <div 
                                            key={player.playerId}
                                            style={{
                                                background: 'rgba(255, 255, 255, 0.05)',
                                                padding: '10px',
                                                borderRadius: '4px',
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center'
                                            }}
                                        >
                                            <span>
                                                {player.playerName}
                                                {player.isGoalkeeper && ' üß§'}
                                            </span>
                                            <button
                                                onClick={() => movePlayerToTeam(player, 'gialli', 'verdi')}
                                                style={{
                                                    background: '#48bb78',
                                                    border: 'none',
                                                    padding: '4px 12px',
                                                    borderRadius: '4px',
                                                    cursor: 'pointer',
                                                    fontSize: '12px',
                                                    color: 'white'
                                                }}
                                            >
                                                ‚Üí VERDI
                                            </button>
                                        </div>
                                    ))}
                                    {teamGialli.length === 0 && (
                                        <p style={{textAlign: 'center', opacity: 0.5}}>Nessun giocatore</p>
                                    )}
                                </div>
                            </div>

                            {/* SQUADRA VERDI */}
                            <div style={{flex: 1, background: 'rgba(72, 187, 120, 0.1)', padding: '15px', borderRadius: '8px', border: '2px solid #48bb78'}}>
                                <h3 style={{color: '#48bb78', marginBottom: '15px'}}>
                                    üü¢ VERDI ({teamVerdi.length})
                                </h3>
                                <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
                                    {teamVerdi.map(player => (
                                        <div 
                                            key={player.playerId}
                                            style={{
                                                background: 'rgba(255, 255, 255, 0.05)',
                                                padding: '10px',
                                                borderRadius: '4px',
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center'
                                            }}
                                        >
                                            <span>
                                                {player.playerName}
                                                {player.isGoalkeeper && ' üß§'}
                                            </span>
                                            <button
                                                onClick={() => movePlayerToTeam(player, 'verdi', 'gialli')}
                                                style={{
                                                    background: '#FFD700',
                                                    border: 'none',
                                                    padding: '4px 12px',
                                                    borderRadius: '4px',
                                                    cursor: 'pointer',
                                                    fontSize: '12px',
                                                    color: 'black'
                                                }}
                                            >
                                                ‚Üê GIALLI
                                            </button>
                                        </div>
                                    ))}
                                    {teamVerdi.length === 0 && (
                                        <p style={{textAlign: 'center', opacity: 0.5}}>Nessun giocatore</p>
                                    )}
                                </div>
                            </div>
                        </div>

                        <div style={{marginTop: '20px', textAlign: 'center'}}>
                            <button
                                className="btn btn-secondary"
                                onClick={() => generateBalancedTeams(adminRegistrations[selectedMatchForTeams.id] || [])}
                                style={{marginRight: '10px'}}
                            >
                                üîÑ Bilancia Automaticamente
                            </button>
                        </div>

                        <div className="modal-actions">
                            <button className="btn btn-secondary" onClick={() => {
                                setShowTeamAssignment(false);
                                setSelectedMatchForTeams(null);
                                setTeamGialli([]);
                                setTeamVerdi([]);
                            }}>
                                Annulla
                            </button>
                            <button className="btn btn-primary" onClick={handleSaveTeams}>
                                ‚úì Salva Squadre
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* üÜï MODALE RISULTATO */}
            {showScoreModal && selectedMatchForScore && (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h2>‚öΩ Inserisci Risultato - {utils.formatMatchDate(selectedMatchForScore.date)}</h2>
                        
                        <div style={{display: 'flex', gap: '20px', marginTop: '20px', alignItems: 'center', justifyContent: 'center'}}>
                            <div style={{textAlign: 'center'}}>
                                <label style={{display: 'block', color: '#FFD700', marginBottom: '8px', fontWeight: 'bold'}}>
                                    üü° GIALLI
                                </label>
                                <input
                                    type="number"
                                    min="0"
                                    value={scoreGialli}
                                    onChange={(e) => setScoreGialli(e.target.value)}
                                    style={{
                                        width: '80px',
                                        height: '60px',
                                        fontSize: '28px',
                                        textAlign: 'center',
                                        background: 'var(--bg-deep)',
                                        border: '2px solid #FFD700',
                                        color: 'white',
                                        borderRadius: '8px'
                                    }}
                                />
                            </div>

                            <span style={{fontSize: '32px', fontWeight: 'bold'}}>-</span>

                            <div style={{textAlign: 'center'}}>
                                <label style={{display: 'block', color: '#48bb78', marginBottom: '8px', fontWeight: 'bold'}}>
                                    üü¢ VERDI
                                </label>
                                <input
                                    type="number"
                                    min="0"
                                    value={scoreVerdi}
                                    onChange={(e) => setScoreVerdi(e.target.value)}
                                    style={{
                                        width: '80px',
                                        height: '60px',
                                        fontSize: '28px',
                                        textAlign: 'center',
                                        background: 'var(--bg-deep)',
                                        border: '2px solid #48bb78',
                                        color: 'white',
                                        borderRadius: '8px'
                                    }}
                                />
                            </div>
                        </div>

                        <div style={{marginTop: '30px'}}>
                            <h4 style={{marginBottom: '15px', color: 'var(--volt)'}}>üèÜ Capocannoniere (opzionale)</h4>
                            <div className="form-group">
                                <label>Nome Giocatore</label>
                                <input
                                    type="text"
                                    value={topScorer}
                                    onChange={(e) => setTopScorer(e.target.value)}
                                    placeholder="Es: Mario Rossi"
                                />
                            </div>
                            <div className="form-group">
                                <label>Numero Gol</label>
                                <input
                                    type="number"
                                    min="1"
                                    value={topScorerGoals}
                                    onChange={(e) => setTopScorerGoals(e.target.value)}
                                    placeholder="Es: 3"
                                />
                            </div>
                        </div>

                        <div className="modal-actions">
                            <button className="btn btn-secondary" onClick={() => {
                                setShowScoreModal(false);
                                setSelectedMatchForScore(null);
                                setScoreGialli('');
                                setScoreVerdi('');
                                setTopScorer('');
                                setTopScorerGoals('');
                            }}>
                                Annulla
                            </button>
                            <button className="btn btn-primary" onClick={handleSaveScore}>
                                ‚úì Salva Risultato
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}

function DebugPage({ users, votes }) {
    const [selectedPlayer, setSelectedPlayer] = useState(null);
    const [editingVote, setEditingVote] = useState(null);
    const [editVoteValues, setEditVoteValues] = useState({});

    const getVoteStats = (playerId) => {
        const playerVotes = votes.filter(v => v.playerId === playerId);
        const seedVotes = playerVotes.filter(v => v.voterId && v.voterId.startsWith('seed'));
        const realVotes = playerVotes.filter(v => v.voterId && !v.voterId.startsWith('seed'));
        return { total: playerVotes.length, seed: seedVotes.length, real: realVotes.length, allVotes: playerVotes };
    };

    const handleEditVote = (vote) => {
        setEditingVote(vote);
        setEditVoteValues(vote.ratings);
    };

    const handleSaveEditedVote = async () => {
        if (!editingVote.id) {
            alert('Impossibile modificare voti senza ID');
            return;
        }
        try {
            await db.collection('votes').doc(editingVote.id).update({ ratings: editVoteValues });
            alert('Voto aggiornato! Ricarica la pagina per vedere le modifiche.');
            setEditingVote(null);
        } catch (err) {
            alert('Errore durante il salvataggio: ' + err.message);
        }
    };

    const handleDeleteVote = async (voteId) => {
        if (!voteId) {
            alert('Impossibile eliminare voti senza ID');
            return;
        }
        if (!confirm('Eliminare questo voto?')) return;
        try {
            await db.collection('votes').doc(voteId).delete();
            alert('Voto eliminato! Ricarica la pagina.');
        } catch (err) {
            alert('Errore durante l\'eliminazione: ' + err.message);
        }
    };

    const players = users.filter(u => !u.id.startsWith('seed'));

if (selectedPlayer) {
    const player = players.find(p => p.id === selectedPlayer);
    if (!player) {
        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>üêõ Debug - Giocatore non trovato</h2>
                    <button onClick={() => setSelectedPlayer(null)} className="btn-back">‚Üê Indietro</button>
                </div>
                <p>Giocatore con ID {selectedPlayer} non trovato</p>
            </div>
        );
    }
    const stats = getVoteStats(player.id);
    const averages = utils.calculateAverages(player.id, votes, player); // üÜï Passa player
        const overall = utils.calculateOverall(averages);

        return (
            <div className="section-container">
                <div className="section-header">
                    <h2>üìä Dettaglio: {player.name}</h2>
                    <button onClick={() => setSelectedPlayer(null)} className="btn-back">‚Üê Indietro</button>
                </div>

                <div className="debug-stats">
                    <div className="debug-stat-box"><div className="stat-value seed">{stats.seed}</div><div className="stat-label">Voti Seed</div></div>
                    <div className="debug-stat-box"><div className="stat-value real">{stats.real}</div><div className="stat-label">Voti Reali</div></div>
                    <div className="debug-stat-box"><div className="stat-value total">{stats.total}</div><div className="stat-label">Totale</div></div>
                    <div className="debug-stat-box"><div className="stat-value overall">{overall ? utils.toBase10(overall).toFixed(2) : '-'}</div><div className="stat-label">Overall</div></div>
                </div>

                <h3>üó≥Ô∏è Tutti i Voti</h3>
                <div className="debug-table-wrapper">
                    <table className="debug-table">
                        <thead>
<tr>
    <th>Votante</th>
    <th>Tipo</th>
    {(() => {
        const playerSkills = getSkillsForPlayer(player);
        return [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche].map(skill => (<th key={skill}>{skill.substring(0, 6)}</th>));
    })()}
    <th>Azioni</th>
</tr>
                        </thead>
                        <tbody>
                            {stats.allVotes.map((vote, index) => {
                                const isSeed = vote.voterId.startsWith('seed');
                                const voterName = isSeed ? 'ü§ñ Seed' : (users.find(u => u.id === vote.voterId)?.name || 'Sconosciuto');
                                return (
                                    <tr key={index} className={index % 2 === 0 ? 'even' : 'odd'}>
                                        <td>{voterName}</td>
                                        <td><span className={`vote-type ${isSeed ? 'seed' : 'real'}`}>{isSeed ? 'Seed' : 'Reale'}</span></td>
{(() => {
    const playerSkills = getSkillsForPlayer(player);
    return [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche].map(skill => (<td key={skill}>{vote.ratings[skill] || '-'}</td>));
})()}                                        <td>
                                            <button onClick={() => handleEditVote(vote)} className="admin-btn" style={{marginRight: '5px'}}>‚úèÔ∏è</button>
                                            <button onClick={() => handleDeleteVote(vote.id)} className="admin-btn btn-delete">üóëÔ∏è</button>
                                        </td>
                                    </tr>
                                );
                            })}
                            <tr className="average-row">
                                <td>üìä MEDIA</td>
                                <td></td>
{(() => {
    const playerSkills = getSkillsForPlayer(player);
    return [...playerSkills.tecniche, ...playerSkills.tattiche, ...playerSkills.fisiche].map(skill => {
        const skillVotes = stats.allVotes.map(v => v.ratings[skill]).filter(v => v !== undefined);
        const avg = skillVotes.length > 0 ? skillVotes.reduce((a, b) => a + b, 0) / skillVotes.length : 0;
        return (<td key={skill}>{avg > 0 ? `${avg.toFixed(2)}` : '-'}</td>);
    });
})()}
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                {editingVote && (
                    <div className="modal-overlay">
                        <div className="modal-content modal-large">
                            <h2>‚úèÔ∏è Modifica Voto</h2>
                            <p>Votante: {editingVote.voterId.startsWith('seed') ? 'ü§ñ Seed' : (users.find(u => u.id === editingVote.voterId)?.name || 'Sconosciuto')}</p>
                            {['tecniche', 'tattiche', 'fisiche'].map(category => (
                                <div key={category} className="vote-edit-category">
                                    <h4 className={`category-${category}`}>{category}</h4>
                                    <div className="vote-edit-grid">
                                        {SKILLS[category].map(skill => (
                                            <div key={skill} className="vote-edit-item">
                                                <label>{skill}</label>
                                                <input 
                                                    type="number" 
                                                    min="1" 
                                                    max="4" 
                                                    step="0.01" 
                                                    value={editVoteValues[skill] || ''} 
                                                    onChange={(e) => setEditVoteValues({...editVoteValues, [skill]: parseFloat(e.target.value) || 0})} 
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                            <div className="modal-actions">
                                <button className="btn btn-secondary" onClick={() => setEditingVote(null)}>Annulla</button>
                                <button className="btn btn-primary" onClick={handleSaveEditedVote}>Salva</button>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    }

    return (
        <div className="section-container">
            <div className="section-header">
                <h2>üêõ Debug - Riepilogo Voti</h2>
            </div>

            <div className="debug-global-stats">
                <div className="debug-stat-box"><div className="stat-value seed">{votes.filter(v => v.voterId && v.voterId.startsWith('seed')).length}</div><div className="stat-label">Voti Seed Totali</div></div>
                <div className="debug-stat-box"><div className="stat-value real">{votes.filter(v => v.voterId && !v.voterId.startsWith('seed')).length}</div><div className="stat-label">Voti Reali Totali</div></div>
                <div className="debug-stat-box"><div className="stat-value total">{votes.length}</div><div className="stat-label">Voti Totali</div></div>
            </div>

            <div className="settings-group">
                <h3>üë• Dettaglio per Giocatore</h3>
                <div className="debug-player-list">
                    {players.map(player => {
                        const stats = getVoteStats(player.id);
const averages = utils.calculateAverages(player.id, votes, player);
			const overall = utils.calculateOverall(averages);
                        return (
                            <div key={player.id} className="debug-player-item" onClick={() => setSelectedPlayer(player.id)}>
                                <span style={{fontWeight: '600', minWidth: '150px'}}>{player.name}</span>
                                <span className="debug-badge seed">Seed: {stats.seed}</span>
                                <span className="debug-badge real">Reali: {stats.real}</span>
                                <span className="debug-badge total">Tot: {stats.total}</span>
                                <span style={{color: '#667eea', fontSize: '14px'}}>OVR: {overall ? utils.toBase10(overall).toFixed(2) : '-'}</span>
                            </div>
                        );
                    })}
                </div>
            </div>
        </div>
    );
}
        function App() {
            const getPendingEmail = () => sessionStorage.getItem('pendingEmail');
            const setPendingEmailStorage = (email) => { if (email) { sessionStorage.setItem('pendingEmail', email); } else { sessionStorage.removeItem('pendingEmail'); } };

            const [currentUser, setCurrentUser] = useState(storage.getCurrentUser());
            const [activeTab, setActiveTab] = useState('valuta');
            const [selectedPlayer, setSelectedPlayer] = useState(null);
            const [viewingProfile, setViewingProfile] = useState(null);
			const [selectedMatch, setSelectedMatch] = useState(null);
            const [users, setUsers] = useState([]);
            const [votes, setVotes] = useState([]);
            const [showRoleModal, setShowRoleModal] = useState(false);
            const [showClaimModal, setShowClaimModal] = useState(false);
            const [pendingEmail, setPendingEmail] = useState(getPendingEmail());
const [loading, setLoading] = useState(true);
const [showAntonioSelector, setShowAntonioSelector] = useState(false);
const [antonioProfiles, setAntonioProfiles] = useState([]);
			
            useEffect(() => {
                const loadData = async () => {
                    setLoading(true);
                    try {
                        let loadedUsers = await storage.getUsers();
                        if (loadedUsers.length === 0) { loadedUsers = []; }
                        const loadedVotes = await storage.getVotes();
                        setUsers(loadedUsers);
                        setVotes(loadedVotes);
                    } catch (error) {
                        console.error('Errore caricamento dati:', error);
                    }
                    setLoading(false);
                };
                loadData();
            }, []);

            useEffect(() => {
                if (loading || currentUser) return;
                const unsubscribe = firebase.auth().onAuthStateChanged((firebaseUser) => {
                    if (firebaseUser && firebaseUser.email) {
                        const email = firebaseUser.email;
                        const existingUser = users.find(u => u.email === email);
                        if (existingUser) {
                            const userWithAdmin = { ...existingUser, isAdmin: email === ADMIN_EMAIL };
                            setCurrentUser(userWithAdmin);
                            storage.setCurrentUser(userWithAdmin);
                            if (!existingUser.preferredRole) setShowRoleModal(true);
                        } else {
                            setPendingEmail(email);
                            setShowClaimModal(true);
                        }
                    }
                });
                return () => unsubscribe();
            }, [loading, users, currentUser]);

const handleLogin = (email) => {
    const existingUser = users.find(u => u.email === email);
    if (existingUser) {
        // üÜï CONTROLLO SE √à ANTONIO (ha 2 profili con stessa email)
        const antonioProfiles = users.filter(u => u.email === email);
        if (antonioProfiles.length > 1) {
            // √à Antonio con profili multipli
            setAntonioProfiles(antonioProfiles);
            setShowAntonioSelector(true);
            return;
        }
        
        // Flusso normale
        const userWithAdmin = { ...existingUser, isAdmin: email === ADMIN_EMAIL };
        setCurrentUser(userWithAdmin);
        storage.setCurrentUser(userWithAdmin);
        if (!existingUser.preferredRole) setShowRoleModal(true);
    } else {
        setPendingEmail(email);
        setPendingEmailStorage(email);
        setShowClaimModal(true);
    }
};

const handleClaimProfile = async (playerId) => {
    const isAdmin = pendingEmail === ADMIN_EMAIL;
    const user = users.find(u => u.id === playerId);
    
    // üÜï RICONOSCIMENTO ANTONIO T
    const isAntonio = user.name === 'Antonio T'; // ‚ö†Ô∏è VERIFICA IL NOME ESATTO NEL TUO DB!
    
    if (isAntonio) {
        // Reclama il profilo esistente (movimento)
        const movementProfile = { 
            ...user, 
            email: pendingEmail, 
            claimed: true, 
            isAdmin,
            isGoalkeeper: false,
            name: 'Antonio T - Movimento'
        };
        
        // Crea nuovo profilo portiere
        const goalkeeperProfile = {
            id: `${user.id}_gk`,
            name: 'Antonio T - Portiere',
            email: pendingEmail,
            avatar: user.avatar || null,
            preferredRole: 'Portiere',
            otherRoles: [],
            claimed: true,
            isAdmin,
            isGoalkeeper: true,
            isInitialPlayer: false,
            hasVotedOffline: true
        };
        
        // Salva entrambi
        await storage.updateUser(movementProfile);
        await storage.updateUser(goalkeeperProfile);
        
        const updatedUsers = users.map(u => u.id === playerId ? movementProfile : u).concat([goalkeeperProfile]);
        setUsers(updatedUsers);
        
        // Mostra modal di selezione
        setAntonioProfiles([movementProfile, goalkeeperProfile]);
        setShowAntonioSelector(true);
        setShowClaimModal(false);
        setPendingEmail(null);
        setPendingEmailStorage(null);
        
    } else {
        // Flusso normale per tutti gli altri
        const isGoalkeeper = user.preferredRole === 'Portiere';
        const claimedUser = { ...user, email: pendingEmail, claimed: true, isAdmin, isGoalkeeper };
        await storage.updateUser(claimedUser);
        const updatedUsers = users.map(u => u.id === playerId ? claimedUser : u);
        setUsers(updatedUsers);
        setCurrentUser(claimedUser);
        storage.setCurrentUser(claimedUser);
        setShowClaimModal(false);
        setPendingEmail(null);
        setPendingEmailStorage(null);
        if (!claimedUser.preferredRole) setShowRoleModal(true);
    }
};

            const handleNewPlayer = async (playerName) => {
                const isAdmin = pendingEmail === ADMIN_EMAIL;
const newUser = { id: `player${users.length + 1}`, name: playerName || pendingEmail.split('@')[0], email: pendingEmail, avatar: null, preferredRole: null, otherRoles: [], claimed: true, isAdmin: isAdmin, isInitialPlayer: false, hasVotedOffline: false, isGoalkeeper: false };                await storage.updateUser(newUser);
                setUsers([...users, newUser]);
                setCurrentUser(newUser);
                storage.setCurrentUser(newUser);
                setShowClaimModal(false);
                setPendingEmail(null);
                setPendingEmailStorage(null);
                setShowRoleModal(true);
            };

            const handleLogout = () => { firebase.auth().signOut(); setCurrentUser(null); storage.setCurrentUser(null); };

            const handleVoteSubmit = async (playerId, ratings) => {
                const newVote = { voterId: currentUser.id, voterName: currentUser.name, voterEmail: currentUser.email, playerId, ratings, timestamp: Date.now(), date: new Date().toISOString() };
                await storage.addVote(newVote);
                setVotes([...votes, newVote]);
                setSelectedPlayer(null);
            };

const handleRolesSave = async (preferredRole, otherRoles) => {
    const isGoalkeeper = preferredRole === 'Portiere';
    const updatedCurrentUser = { ...currentUser, preferredRole, otherRoles, isGoalkeeper };
                await storage.updateUser(updatedCurrentUser);
                const updatedUsers = users.map(u => u.id === currentUser.id ? updatedCurrentUser : u);
                setUsers(updatedUsers);
                setCurrentUser(updatedCurrentUser);
                storage.setCurrentUser(updatedCurrentUser);
                setShowRoleModal(false);
            };
// üÜï HANDLER SELEZIONE PROFILO ANTONIO
const handleAntonioProfileSelect = (profile) => {
    setCurrentUser(profile);
    storage.setCurrentUser(profile);
    setShowAntonioSelector(false);
    setAntonioProfiles([]);
};
            if (loading) {
                return (<div className="login-container"><div className="login-card"><h1>‚öΩ Calcetto Rating</h1><p>Caricamento in corso...</p></div></div>);
            }

            if (!currentUser) {
                return (<>{showClaimModal && <ClaimProfileModal users={users} onClaim={handleClaimProfile} onNewPlayer={handleNewPlayer} />}<LoginPage onLogin={handleLogin} /></>);
            }

            return (
                <div className="app-container">
{showRoleModal && <RoleSelectionModal onSave={handleRolesSave} />}
{showAntonioSelector && <ProfileSelectorModal profiles={antonioProfiles} onSelect={handleAntonioProfileSelect} />}
                    <Header user={currentUser} onLogout={handleLogout} />
                    <div className="nav-tabs">
						<button className={`nav-tab ${activeTab === 'partite' ? 'active' : ''}`} 
        onClick={() => { 
            setActiveTab('partite'); 
            setSelectedPlayer(null); 
            setViewingProfile(null); 
            setSelectedMatch(null); 
        }}>
    üèÜ Partite
</button>
                        <button className={`nav-tab ${activeTab === 'valuta' ? 'active' : ''}`} onClick={() => { setActiveTab('valuta'); setSelectedPlayer(null); setViewingProfile(null); }}>‚öΩ Valuta</button>
                        <button className={`nav-tab ${activeTab === 'profilo' ? 'active' : ''}`} onClick={() => { setActiveTab('profilo'); setSelectedPlayer(null); setViewingProfile(null); }}>üë§ Profilo</button>
                        <button className={`nav-tab ${activeTab === 'classifiche' ? 'active' : ''}`} onClick={() => { setActiveTab('classifiche'); setSelectedPlayer(null); setViewingProfile(null); }}>üìä Classifiche</button>
                        <button className={`nav-tab ${activeTab === 'impostazioni' ? 'active' : ''}`} onClick={() => { setActiveTab('impostazioni'); setSelectedPlayer(null); setViewingProfile(null); }}>‚öôÔ∏è Impostazioni</button>
                        {currentUser.isAdmin && <button className={`nav-tab ${activeTab === 'admin' ? 'active' : ''}`} onClick={() => { setActiveTab('admin'); setSelectedPlayer(null); setViewingProfile(null); }}>üîß Admin</button>}
                        {currentUser.isAdmin && <button className={`nav-tab ${activeTab === 'debug' ? 'active' : ''}`} onClick={() => { setActiveTab('debug'); setSelectedPlayer(null); setViewingProfile(null); }}>üêõ Debug</button>}
                    </div>
                    <div className="content">
                        {viewingProfile ? (
                            <PlayerProfile player={users.find(u => u.id === viewingProfile)} votes={votes} isOwnProfile={viewingProfile === currentUser.id} />
                        ) : selectedPlayer ? (
                            <RatingForm player={users.find(u => u.id === selectedPlayer)} onSubmit={handleVoteSubmit} onCancel={() => setSelectedPlayer(null)} />
                        ) : activeTab === 'partite' ? (
    selectedMatch ? (
        <MatchDetailRouter 
            matchId={selectedMatch}
            currentUser={currentUser}
            onBack={() => setSelectedMatch(null)}
        />
    ) : (
        <MatchesPage 
            currentUser={currentUser} 
            users={users}
            onSelectMatch={setSelectedMatch} 
        />
    )

						) : activeTab === 'valuta' ? (
                            <PlayersListPage users={users} currentUser={currentUser} votes={votes} onSelectPlayer={setSelectedPlayer} />
                        ) : activeTab === 'profilo' ? (
                            <PlayerProfile player={currentUser} votes={votes} isOwnProfile={true} />
                        ) : activeTab === 'classifiche' ? (
    <ClassifichePage users={users} votes={votes} currentUser={currentUser} onViewProfile={setViewingProfile} />
                        ) : activeTab === 'admin' && currentUser.isAdmin ? (
                            <AdminPage users={users} setUsers={setUsers} votes={votes} setVotes={setVotes} />
                        ) : activeTab === 'debug' && currentUser.isAdmin ? (
                            <DebugPage users={users} votes={votes} />
                        ) : (
                            <SettingsPage user={currentUser} onUpdateUser={async (updatedUser) => { await storage.updateUser(updatedUser); const updatedUsers = users.map(u => u.id === updatedUser.id ? updatedUser : u); setUsers(updatedUsers); setCurrentUser(updatedUser); storage.setCurrentUser(updatedUser); }} />
                        )}
                    </div>
                </div>
            );
        }

        try {
            ReactDOM.render(<App />, document.getElementById('root'));
        } catch (error) {
            document.getElementById('root').innerHTML = '<div style="color:white;text-align:center;padding:50px;"><h2>Errore caricamento</h2><p>' + error.message + '</p></div>';
        }
    </script>
<!-- ¬© 2025 Luigi Oliviero | Calcetto Rating App | Tutti i diritti riservati -->
</body>
</html>
